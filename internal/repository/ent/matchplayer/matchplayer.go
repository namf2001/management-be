// Code generated by ent, DO NOT EDIT.

package matchplayer

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the matchplayer type in the database.
	Label = "match_player"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldMatchID holds the string denoting the match_id field in the database.
	FieldMatchID = "match_id"
	// FieldPlayerID holds the string denoting the player_id field in the database.
	FieldPlayerID = "player_id"
	// FieldMinutesPlayed holds the string denoting the minutes_played field in the database.
	FieldMinutesPlayed = "minutes_played"
	// FieldGoalsScored holds the string denoting the goals_scored field in the database.
	FieldGoalsScored = "goals_scored"
	// FieldAssists holds the string denoting the assists field in the database.
	FieldAssists = "assists"
	// FieldYellowCards holds the string denoting the yellow_cards field in the database.
	FieldYellowCards = "yellow_cards"
	// FieldRedCard holds the string denoting the red_card field in the database.
	FieldRedCard = "red_card"
	// FieldCreatedAt holds the string denoting the created_at field in the database.
	FieldCreatedAt = "created_at"
	// FieldUpdatedAt holds the string denoting the updated_at field in the database.
	FieldUpdatedAt = "updated_at"
	// EdgeMatch holds the string denoting the match edge name in mutations.
	EdgeMatch = "match"
	// EdgePlayer holds the string denoting the player edge name in mutations.
	EdgePlayer = "player"
	// Table holds the table name of the matchplayer in the database.
	Table = "match_players"
	// MatchTable is the table that holds the match relation/edge.
	MatchTable = "match_players"
	// MatchInverseTable is the table name for the Match entity.
	// It exists in this package in order to avoid circular dependency with the "match" package.
	MatchInverseTable = "matches"
	// MatchColumn is the table column denoting the match relation/edge.
	MatchColumn = "match_id"
	// PlayerTable is the table that holds the player relation/edge.
	PlayerTable = "match_players"
	// PlayerInverseTable is the table name for the Player entity.
	// It exists in this package in order to avoid circular dependency with the "player" package.
	PlayerInverseTable = "players"
	// PlayerColumn is the table column denoting the player relation/edge.
	PlayerColumn = "player_id"
)

// Columns holds all SQL columns for matchplayer fields.
var Columns = []string{
	FieldID,
	FieldMatchID,
	FieldPlayerID,
	FieldMinutesPlayed,
	FieldGoalsScored,
	FieldAssists,
	FieldYellowCards,
	FieldRedCard,
	FieldCreatedAt,
	FieldUpdatedAt,
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	return false
}

// OrderOption defines the ordering options for the MatchPlayer queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByMatchID orders the results by the match_id field.
func ByMatchID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMatchID, opts...).ToFunc()
}

// ByPlayerID orders the results by the player_id field.
func ByPlayerID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPlayerID, opts...).ToFunc()
}

// ByMinutesPlayed orders the results by the minutes_played field.
func ByMinutesPlayed(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldMinutesPlayed, opts...).ToFunc()
}

// ByGoalsScored orders the results by the goals_scored field.
func ByGoalsScored(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldGoalsScored, opts...).ToFunc()
}

// ByAssists orders the results by the assists field.
func ByAssists(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAssists, opts...).ToFunc()
}

// ByYellowCards orders the results by the yellow_cards field.
func ByYellowCards(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldYellowCards, opts...).ToFunc()
}

// ByRedCard orders the results by the red_card field.
func ByRedCard(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldRedCard, opts...).ToFunc()
}

// ByCreatedAt orders the results by the created_at field.
func ByCreatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldCreatedAt, opts...).ToFunc()
}

// ByUpdatedAt orders the results by the updated_at field.
func ByUpdatedAt(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldUpdatedAt, opts...).ToFunc()
}

// ByMatchField orders the results by match field.
func ByMatchField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newMatchStep(), sql.OrderByField(field, opts...))
	}
}

// ByPlayerField orders the results by player field.
func ByPlayerField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPlayerStep(), sql.OrderByField(field, opts...))
	}
}
func newMatchStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(MatchInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, MatchTable, MatchColumn),
	)
}
func newPlayerStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PlayerInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, PlayerTable, PlayerColumn),
	)
}
