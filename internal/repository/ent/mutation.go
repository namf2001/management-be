// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"management-be/internal/repository/ent/department"
	"management-be/internal/repository/ent/match"
	"management-be/internal/repository/ent/matchplayer"
	"management-be/internal/repository/ent/player"
	"management-be/internal/repository/ent/playerstatistic"
	"management-be/internal/repository/ent/predicate"
	"management-be/internal/repository/ent/team"
	"management-be/internal/repository/ent/teamfee"
	"management-be/internal/repository/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDepartment      = "Department"
	TypeMatch           = "Match"
	TypeMatchPlayer     = "MatchPlayer"
	TypePlayer          = "Player"
	TypePlayerStatistic = "PlayerStatistic"
	TypeTeam            = "Team"
	TypeTeamFee         = "TeamFee"
	TypeUser            = "User"
)

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op             Op
	typ            string
	id             *int32
	name           *string
	description    *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	players        map[int32]struct{}
	removedplayers map[int32]struct{}
	clearedplayers bool
	done           bool
	oldValue       func(context.Context) (*Department, error)
	predicates     []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id int32) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *DepartmentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DepartmentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DepartmentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[department.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DepartmentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[department.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DepartmentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, department.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DepartmentMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[department.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DepartmentMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, department.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DepartmentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[department.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DepartmentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, department.FieldUpdatedAt)
}

// AddPlayerIDs adds the "players" edge to the Player entity by ids.
func (m *DepartmentMutation) AddPlayerIDs(ids ...int32) {
	if m.players == nil {
		m.players = make(map[int32]struct{})
	}
	for i := range ids {
		m.players[ids[i]] = struct{}{}
	}
}

// ClearPlayers clears the "players" edge to the Player entity.
func (m *DepartmentMutation) ClearPlayers() {
	m.clearedplayers = true
}

// PlayersCleared reports if the "players" edge to the Player entity was cleared.
func (m *DepartmentMutation) PlayersCleared() bool {
	return m.clearedplayers
}

// RemovePlayerIDs removes the "players" edge to the Player entity by IDs.
func (m *DepartmentMutation) RemovePlayerIDs(ids ...int32) {
	if m.removedplayers == nil {
		m.removedplayers = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.players, ids[i])
		m.removedplayers[ids[i]] = struct{}{}
	}
}

// RemovedPlayers returns the removed IDs of the "players" edge to the Player entity.
func (m *DepartmentMutation) RemovedPlayersIDs() (ids []int32) {
	for id := range m.removedplayers {
		ids = append(ids, id)
	}
	return
}

// PlayersIDs returns the "players" edge IDs in the mutation.
func (m *DepartmentMutation) PlayersIDs() (ids []int32) {
	for id := range m.players {
		ids = append(ids, id)
	}
	return
}

// ResetPlayers resets all changes to the "players" edge.
func (m *DepartmentMutation) ResetPlayers() {
	m.players = nil
	m.clearedplayers = false
	m.removedplayers = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.description != nil {
		fields = append(fields, department.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	case department.FieldDescription:
		return m.Description()
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldDescription:
		return m.OldDescription(ctx)
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldDescription) {
		fields = append(fields, department.FieldDescription)
	}
	if m.FieldCleared(department.FieldCreatedAt) {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.FieldCleared(department.FieldUpdatedAt) {
		fields = append(fields, department.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldDescription:
		m.ClearDescription()
		return nil
	case department.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldDescription:
		m.ResetDescription()
		return nil
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.players != nil {
		edges = append(edges, department.EdgePlayers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.players))
		for id := range m.players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplayers != nil {
		edges = append(edges, department.EdgePlayers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgePlayers:
		ids := make([]ent.Value, 0, len(m.removedplayers))
		for id := range m.removedplayers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplayers {
		edges = append(edges, department.EdgePlayers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgePlayers:
		return m.clearedplayers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgePlayers:
		m.ResetPlayers()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// MatchMutation represents an operation that mutates the Match nodes in the graph.
type MatchMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int32
	match_date           *time.Time
	venue                *string
	is_home_game         *bool
	our_score            *int32
	addour_score         *int32
	opponent_score       *int32
	addopponent_score    *int32
	status               *string
	notes                *string
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	match_players        map[int32]struct{}
	removedmatch_players map[int32]struct{}
	clearedmatch_players bool
	team                 *int32
	clearedteam          bool
	done                 bool
	oldValue             func(context.Context) (*Match, error)
	predicates           []predicate.Match
}

var _ ent.Mutation = (*MatchMutation)(nil)

// matchOption allows management of the mutation configuration using functional options.
type matchOption func(*MatchMutation)

// newMatchMutation creates new mutation for the Match entity.
func newMatchMutation(c config, op Op, opts ...matchOption) *MatchMutation {
	m := &MatchMutation{
		config:        c,
		op:            op,
		typ:           TypeMatch,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchID sets the ID field of the mutation.
func withMatchID(id int32) matchOption {
	return func(m *MatchMutation) {
		var (
			err   error
			once  sync.Once
			value *Match
		)
		m.oldValue = func(ctx context.Context) (*Match, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Match.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatch sets the old Match of the mutation.
func withMatch(node *Match) matchOption {
	return func(m *MatchMutation) {
		m.oldValue = func(context.Context) (*Match, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Match entities.
func (m *MatchMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Match.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOpponentTeamID sets the "opponent_team_id" field.
func (m *MatchMutation) SetOpponentTeamID(i int32) {
	m.team = &i
}

// OpponentTeamID returns the value of the "opponent_team_id" field in the mutation.
func (m *MatchMutation) OpponentTeamID() (r int32, exists bool) {
	v := m.team
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentTeamID returns the old "opponent_team_id" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldOpponentTeamID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpponentTeamID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpponentTeamID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentTeamID: %w", err)
	}
	return oldValue.OpponentTeamID, nil
}

// ClearOpponentTeamID clears the value of the "opponent_team_id" field.
func (m *MatchMutation) ClearOpponentTeamID() {
	m.team = nil
	m.clearedFields[match.FieldOpponentTeamID] = struct{}{}
}

// OpponentTeamIDCleared returns if the "opponent_team_id" field was cleared in this mutation.
func (m *MatchMutation) OpponentTeamIDCleared() bool {
	_, ok := m.clearedFields[match.FieldOpponentTeamID]
	return ok
}

// ResetOpponentTeamID resets all changes to the "opponent_team_id" field.
func (m *MatchMutation) ResetOpponentTeamID() {
	m.team = nil
	delete(m.clearedFields, match.FieldOpponentTeamID)
}

// SetMatchDate sets the "match_date" field.
func (m *MatchMutation) SetMatchDate(t time.Time) {
	m.match_date = &t
}

// MatchDate returns the value of the "match_date" field in the mutation.
func (m *MatchMutation) MatchDate() (r time.Time, exists bool) {
	v := m.match_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchDate returns the old "match_date" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldMatchDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchDate: %w", err)
	}
	return oldValue.MatchDate, nil
}

// ResetMatchDate resets all changes to the "match_date" field.
func (m *MatchMutation) ResetMatchDate() {
	m.match_date = nil
}

// SetVenue sets the "venue" field.
func (m *MatchMutation) SetVenue(s string) {
	m.venue = &s
}

// Venue returns the value of the "venue" field in the mutation.
func (m *MatchMutation) Venue() (r string, exists bool) {
	v := m.venue
	if v == nil {
		return
	}
	return *v, true
}

// OldVenue returns the old "venue" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldVenue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVenue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVenue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVenue: %w", err)
	}
	return oldValue.Venue, nil
}

// ClearVenue clears the value of the "venue" field.
func (m *MatchMutation) ClearVenue() {
	m.venue = nil
	m.clearedFields[match.FieldVenue] = struct{}{}
}

// VenueCleared returns if the "venue" field was cleared in this mutation.
func (m *MatchMutation) VenueCleared() bool {
	_, ok := m.clearedFields[match.FieldVenue]
	return ok
}

// ResetVenue resets all changes to the "venue" field.
func (m *MatchMutation) ResetVenue() {
	m.venue = nil
	delete(m.clearedFields, match.FieldVenue)
}

// SetIsHomeGame sets the "is_home_game" field.
func (m *MatchMutation) SetIsHomeGame(b bool) {
	m.is_home_game = &b
}

// IsHomeGame returns the value of the "is_home_game" field in the mutation.
func (m *MatchMutation) IsHomeGame() (r bool, exists bool) {
	v := m.is_home_game
	if v == nil {
		return
	}
	return *v, true
}

// OldIsHomeGame returns the old "is_home_game" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldIsHomeGame(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsHomeGame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsHomeGame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsHomeGame: %w", err)
	}
	return oldValue.IsHomeGame, nil
}

// ClearIsHomeGame clears the value of the "is_home_game" field.
func (m *MatchMutation) ClearIsHomeGame() {
	m.is_home_game = nil
	m.clearedFields[match.FieldIsHomeGame] = struct{}{}
}

// IsHomeGameCleared returns if the "is_home_game" field was cleared in this mutation.
func (m *MatchMutation) IsHomeGameCleared() bool {
	_, ok := m.clearedFields[match.FieldIsHomeGame]
	return ok
}

// ResetIsHomeGame resets all changes to the "is_home_game" field.
func (m *MatchMutation) ResetIsHomeGame() {
	m.is_home_game = nil
	delete(m.clearedFields, match.FieldIsHomeGame)
}

// SetOurScore sets the "our_score" field.
func (m *MatchMutation) SetOurScore(i int32) {
	m.our_score = &i
	m.addour_score = nil
}

// OurScore returns the value of the "our_score" field in the mutation.
func (m *MatchMutation) OurScore() (r int32, exists bool) {
	v := m.our_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOurScore returns the old "our_score" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldOurScore(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOurScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOurScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOurScore: %w", err)
	}
	return oldValue.OurScore, nil
}

// AddOurScore adds i to the "our_score" field.
func (m *MatchMutation) AddOurScore(i int32) {
	if m.addour_score != nil {
		*m.addour_score += i
	} else {
		m.addour_score = &i
	}
}

// AddedOurScore returns the value that was added to the "our_score" field in this mutation.
func (m *MatchMutation) AddedOurScore() (r int32, exists bool) {
	v := m.addour_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearOurScore clears the value of the "our_score" field.
func (m *MatchMutation) ClearOurScore() {
	m.our_score = nil
	m.addour_score = nil
	m.clearedFields[match.FieldOurScore] = struct{}{}
}

// OurScoreCleared returns if the "our_score" field was cleared in this mutation.
func (m *MatchMutation) OurScoreCleared() bool {
	_, ok := m.clearedFields[match.FieldOurScore]
	return ok
}

// ResetOurScore resets all changes to the "our_score" field.
func (m *MatchMutation) ResetOurScore() {
	m.our_score = nil
	m.addour_score = nil
	delete(m.clearedFields, match.FieldOurScore)
}

// SetOpponentScore sets the "opponent_score" field.
func (m *MatchMutation) SetOpponentScore(i int32) {
	m.opponent_score = &i
	m.addopponent_score = nil
}

// OpponentScore returns the value of the "opponent_score" field in the mutation.
func (m *MatchMutation) OpponentScore() (r int32, exists bool) {
	v := m.opponent_score
	if v == nil {
		return
	}
	return *v, true
}

// OldOpponentScore returns the old "opponent_score" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldOpponentScore(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpponentScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpponentScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpponentScore: %w", err)
	}
	return oldValue.OpponentScore, nil
}

// AddOpponentScore adds i to the "opponent_score" field.
func (m *MatchMutation) AddOpponentScore(i int32) {
	if m.addopponent_score != nil {
		*m.addopponent_score += i
	} else {
		m.addopponent_score = &i
	}
}

// AddedOpponentScore returns the value that was added to the "opponent_score" field in this mutation.
func (m *MatchMutation) AddedOpponentScore() (r int32, exists bool) {
	v := m.addopponent_score
	if v == nil {
		return
	}
	return *v, true
}

// ClearOpponentScore clears the value of the "opponent_score" field.
func (m *MatchMutation) ClearOpponentScore() {
	m.opponent_score = nil
	m.addopponent_score = nil
	m.clearedFields[match.FieldOpponentScore] = struct{}{}
}

// OpponentScoreCleared returns if the "opponent_score" field was cleared in this mutation.
func (m *MatchMutation) OpponentScoreCleared() bool {
	_, ok := m.clearedFields[match.FieldOpponentScore]
	return ok
}

// ResetOpponentScore resets all changes to the "opponent_score" field.
func (m *MatchMutation) ResetOpponentScore() {
	m.opponent_score = nil
	m.addopponent_score = nil
	delete(m.clearedFields, match.FieldOpponentScore)
}

// SetStatus sets the "status" field.
func (m *MatchMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *MatchMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MatchMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[match.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MatchMutation) StatusCleared() bool {
	_, ok := m.clearedFields[match.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MatchMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, match.FieldStatus)
}

// SetNotes sets the "notes" field.
func (m *MatchMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *MatchMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *MatchMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[match.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *MatchMutation) NotesCleared() bool {
	_, ok := m.clearedFields[match.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *MatchMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, match.FieldNotes)
}

// SetCreatedAt sets the "created_at" field.
func (m *MatchMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MatchMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MatchMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[match.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MatchMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[match.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MatchMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, match.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MatchMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MatchMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Match entity.
// If the Match object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MatchMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[match.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MatchMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[match.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MatchMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, match.FieldUpdatedAt)
}

// AddMatchPlayerIDs adds the "match_players" edge to the MatchPlayer entity by ids.
func (m *MatchMutation) AddMatchPlayerIDs(ids ...int32) {
	if m.match_players == nil {
		m.match_players = make(map[int32]struct{})
	}
	for i := range ids {
		m.match_players[ids[i]] = struct{}{}
	}
}

// ClearMatchPlayers clears the "match_players" edge to the MatchPlayer entity.
func (m *MatchMutation) ClearMatchPlayers() {
	m.clearedmatch_players = true
}

// MatchPlayersCleared reports if the "match_players" edge to the MatchPlayer entity was cleared.
func (m *MatchMutation) MatchPlayersCleared() bool {
	return m.clearedmatch_players
}

// RemoveMatchPlayerIDs removes the "match_players" edge to the MatchPlayer entity by IDs.
func (m *MatchMutation) RemoveMatchPlayerIDs(ids ...int32) {
	if m.removedmatch_players == nil {
		m.removedmatch_players = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.match_players, ids[i])
		m.removedmatch_players[ids[i]] = struct{}{}
	}
}

// RemovedMatchPlayers returns the removed IDs of the "match_players" edge to the MatchPlayer entity.
func (m *MatchMutation) RemovedMatchPlayersIDs() (ids []int32) {
	for id := range m.removedmatch_players {
		ids = append(ids, id)
	}
	return
}

// MatchPlayersIDs returns the "match_players" edge IDs in the mutation.
func (m *MatchMutation) MatchPlayersIDs() (ids []int32) {
	for id := range m.match_players {
		ids = append(ids, id)
	}
	return
}

// ResetMatchPlayers resets all changes to the "match_players" edge.
func (m *MatchMutation) ResetMatchPlayers() {
	m.match_players = nil
	m.clearedmatch_players = false
	m.removedmatch_players = nil
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *MatchMutation) SetTeamID(id int32) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *MatchMutation) ClearTeam() {
	m.clearedteam = true
	m.clearedFields[match.FieldOpponentTeamID] = struct{}{}
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *MatchMutation) TeamCleared() bool {
	return m.OpponentTeamIDCleared() || m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *MatchMutation) TeamID() (id int32, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *MatchMutation) TeamIDs() (ids []int32) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *MatchMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the MatchMutation builder.
func (m *MatchMutation) Where(ps ...predicate.Match) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Match, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Match).
func (m *MatchMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.team != nil {
		fields = append(fields, match.FieldOpponentTeamID)
	}
	if m.match_date != nil {
		fields = append(fields, match.FieldMatchDate)
	}
	if m.venue != nil {
		fields = append(fields, match.FieldVenue)
	}
	if m.is_home_game != nil {
		fields = append(fields, match.FieldIsHomeGame)
	}
	if m.our_score != nil {
		fields = append(fields, match.FieldOurScore)
	}
	if m.opponent_score != nil {
		fields = append(fields, match.FieldOpponentScore)
	}
	if m.status != nil {
		fields = append(fields, match.FieldStatus)
	}
	if m.notes != nil {
		fields = append(fields, match.FieldNotes)
	}
	if m.created_at != nil {
		fields = append(fields, match.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, match.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case match.FieldOpponentTeamID:
		return m.OpponentTeamID()
	case match.FieldMatchDate:
		return m.MatchDate()
	case match.FieldVenue:
		return m.Venue()
	case match.FieldIsHomeGame:
		return m.IsHomeGame()
	case match.FieldOurScore:
		return m.OurScore()
	case match.FieldOpponentScore:
		return m.OpponentScore()
	case match.FieldStatus:
		return m.Status()
	case match.FieldNotes:
		return m.Notes()
	case match.FieldCreatedAt:
		return m.CreatedAt()
	case match.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case match.FieldOpponentTeamID:
		return m.OldOpponentTeamID(ctx)
	case match.FieldMatchDate:
		return m.OldMatchDate(ctx)
	case match.FieldVenue:
		return m.OldVenue(ctx)
	case match.FieldIsHomeGame:
		return m.OldIsHomeGame(ctx)
	case match.FieldOurScore:
		return m.OldOurScore(ctx)
	case match.FieldOpponentScore:
		return m.OldOpponentScore(ctx)
	case match.FieldStatus:
		return m.OldStatus(ctx)
	case match.FieldNotes:
		return m.OldNotes(ctx)
	case match.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case match.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Match field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) SetField(name string, value ent.Value) error {
	switch name {
	case match.FieldOpponentTeamID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentTeamID(v)
		return nil
	case match.FieldMatchDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchDate(v)
		return nil
	case match.FieldVenue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVenue(v)
		return nil
	case match.FieldIsHomeGame:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsHomeGame(v)
		return nil
	case match.FieldOurScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOurScore(v)
		return nil
	case match.FieldOpponentScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpponentScore(v)
		return nil
	case match.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case match.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case match.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case match.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchMutation) AddedFields() []string {
	var fields []string
	if m.addour_score != nil {
		fields = append(fields, match.FieldOurScore)
	}
	if m.addopponent_score != nil {
		fields = append(fields, match.FieldOpponentScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case match.FieldOurScore:
		return m.AddedOurScore()
	case match.FieldOpponentScore:
		return m.AddedOpponentScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchMutation) AddField(name string, value ent.Value) error {
	switch name {
	case match.FieldOurScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOurScore(v)
		return nil
	case match.FieldOpponentScore:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOpponentScore(v)
		return nil
	}
	return fmt.Errorf("unknown Match numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(match.FieldOpponentTeamID) {
		fields = append(fields, match.FieldOpponentTeamID)
	}
	if m.FieldCleared(match.FieldVenue) {
		fields = append(fields, match.FieldVenue)
	}
	if m.FieldCleared(match.FieldIsHomeGame) {
		fields = append(fields, match.FieldIsHomeGame)
	}
	if m.FieldCleared(match.FieldOurScore) {
		fields = append(fields, match.FieldOurScore)
	}
	if m.FieldCleared(match.FieldOpponentScore) {
		fields = append(fields, match.FieldOpponentScore)
	}
	if m.FieldCleared(match.FieldStatus) {
		fields = append(fields, match.FieldStatus)
	}
	if m.FieldCleared(match.FieldNotes) {
		fields = append(fields, match.FieldNotes)
	}
	if m.FieldCleared(match.FieldCreatedAt) {
		fields = append(fields, match.FieldCreatedAt)
	}
	if m.FieldCleared(match.FieldUpdatedAt) {
		fields = append(fields, match.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchMutation) ClearField(name string) error {
	switch name {
	case match.FieldOpponentTeamID:
		m.ClearOpponentTeamID()
		return nil
	case match.FieldVenue:
		m.ClearVenue()
		return nil
	case match.FieldIsHomeGame:
		m.ClearIsHomeGame()
		return nil
	case match.FieldOurScore:
		m.ClearOurScore()
		return nil
	case match.FieldOpponentScore:
		m.ClearOpponentScore()
		return nil
	case match.FieldStatus:
		m.ClearStatus()
		return nil
	case match.FieldNotes:
		m.ClearNotes()
		return nil
	case match.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case match.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Match nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchMutation) ResetField(name string) error {
	switch name {
	case match.FieldOpponentTeamID:
		m.ResetOpponentTeamID()
		return nil
	case match.FieldMatchDate:
		m.ResetMatchDate()
		return nil
	case match.FieldVenue:
		m.ResetVenue()
		return nil
	case match.FieldIsHomeGame:
		m.ResetIsHomeGame()
		return nil
	case match.FieldOurScore:
		m.ResetOurScore()
		return nil
	case match.FieldOpponentScore:
		m.ResetOpponentScore()
		return nil
	case match.FieldStatus:
		m.ResetStatus()
		return nil
	case match.FieldNotes:
		m.ResetNotes()
		return nil
	case match.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case match.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Match field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.match_players != nil {
		edges = append(edges, match.EdgeMatchPlayers)
	}
	if m.team != nil {
		edges = append(edges, match.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeMatchPlayers:
		ids := make([]ent.Value, 0, len(m.match_players))
		for id := range m.match_players {
			ids = append(ids, id)
		}
		return ids
	case match.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmatch_players != nil {
		edges = append(edges, match.EdgeMatchPlayers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case match.EdgeMatchPlayers:
		ids := make([]ent.Value, 0, len(m.removedmatch_players))
		for id := range m.removedmatch_players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmatch_players {
		edges = append(edges, match.EdgeMatchPlayers)
	}
	if m.clearedteam {
		edges = append(edges, match.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchMutation) EdgeCleared(name string) bool {
	switch name {
	case match.EdgeMatchPlayers:
		return m.clearedmatch_players
	case match.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchMutation) ClearEdge(name string) error {
	switch name {
	case match.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Match unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchMutation) ResetEdge(name string) error {
	switch name {
	case match.EdgeMatchPlayers:
		m.ResetMatchPlayers()
		return nil
	case match.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Match edge %s", name)
}

// MatchPlayerMutation represents an operation that mutates the MatchPlayer nodes in the graph.
type MatchPlayerMutation struct {
	config
	op                Op
	typ               string
	id                *int32
	minutes_played    *int32
	addminutes_played *int32
	goals_scored      *int32
	addgoals_scored   *int32
	assists           *int32
	addassists        *int32
	yellow_cards      *int32
	addyellow_cards   *int32
	red_card          *bool
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	match             *int32
	clearedmatch      bool
	player            *int32
	clearedplayer     bool
	done              bool
	oldValue          func(context.Context) (*MatchPlayer, error)
	predicates        []predicate.MatchPlayer
}

var _ ent.Mutation = (*MatchPlayerMutation)(nil)

// matchplayerOption allows management of the mutation configuration using functional options.
type matchplayerOption func(*MatchPlayerMutation)

// newMatchPlayerMutation creates new mutation for the MatchPlayer entity.
func newMatchPlayerMutation(c config, op Op, opts ...matchplayerOption) *MatchPlayerMutation {
	m := &MatchPlayerMutation{
		config:        c,
		op:            op,
		typ:           TypeMatchPlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMatchPlayerID sets the ID field of the mutation.
func withMatchPlayerID(id int32) matchplayerOption {
	return func(m *MatchPlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *MatchPlayer
		)
		m.oldValue = func(ctx context.Context) (*MatchPlayer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MatchPlayer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMatchPlayer sets the old MatchPlayer of the mutation.
func withMatchPlayer(node *MatchPlayer) matchplayerOption {
	return func(m *MatchPlayerMutation) {
		m.oldValue = func(context.Context) (*MatchPlayer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MatchPlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MatchPlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MatchPlayer entities.
func (m *MatchPlayerMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MatchPlayerMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MatchPlayerMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MatchPlayer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMatchID sets the "match_id" field.
func (m *MatchPlayerMutation) SetMatchID(i int32) {
	m.match = &i
}

// MatchID returns the value of the "match_id" field in the mutation.
func (m *MatchPlayerMutation) MatchID() (r int32, exists bool) {
	v := m.match
	if v == nil {
		return
	}
	return *v, true
}

// OldMatchID returns the old "match_id" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldMatchID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMatchID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMatchID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMatchID: %w", err)
	}
	return oldValue.MatchID, nil
}

// ClearMatchID clears the value of the "match_id" field.
func (m *MatchPlayerMutation) ClearMatchID() {
	m.match = nil
	m.clearedFields[matchplayer.FieldMatchID] = struct{}{}
}

// MatchIDCleared returns if the "match_id" field was cleared in this mutation.
func (m *MatchPlayerMutation) MatchIDCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldMatchID]
	return ok
}

// ResetMatchID resets all changes to the "match_id" field.
func (m *MatchPlayerMutation) ResetMatchID() {
	m.match = nil
	delete(m.clearedFields, matchplayer.FieldMatchID)
}

// SetPlayerID sets the "player_id" field.
func (m *MatchPlayerMutation) SetPlayerID(i int32) {
	m.player = &i
}

// PlayerID returns the value of the "player_id" field in the mutation.
func (m *MatchPlayerMutation) PlayerID() (r int32, exists bool) {
	v := m.player
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerID returns the old "player_id" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldPlayerID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerID: %w", err)
	}
	return oldValue.PlayerID, nil
}

// ClearPlayerID clears the value of the "player_id" field.
func (m *MatchPlayerMutation) ClearPlayerID() {
	m.player = nil
	m.clearedFields[matchplayer.FieldPlayerID] = struct{}{}
}

// PlayerIDCleared returns if the "player_id" field was cleared in this mutation.
func (m *MatchPlayerMutation) PlayerIDCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldPlayerID]
	return ok
}

// ResetPlayerID resets all changes to the "player_id" field.
func (m *MatchPlayerMutation) ResetPlayerID() {
	m.player = nil
	delete(m.clearedFields, matchplayer.FieldPlayerID)
}

// SetMinutesPlayed sets the "minutes_played" field.
func (m *MatchPlayerMutation) SetMinutesPlayed(i int32) {
	m.minutes_played = &i
	m.addminutes_played = nil
}

// MinutesPlayed returns the value of the "minutes_played" field in the mutation.
func (m *MatchPlayerMutation) MinutesPlayed() (r int32, exists bool) {
	v := m.minutes_played
	if v == nil {
		return
	}
	return *v, true
}

// OldMinutesPlayed returns the old "minutes_played" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldMinutesPlayed(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinutesPlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinutesPlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinutesPlayed: %w", err)
	}
	return oldValue.MinutesPlayed, nil
}

// AddMinutesPlayed adds i to the "minutes_played" field.
func (m *MatchPlayerMutation) AddMinutesPlayed(i int32) {
	if m.addminutes_played != nil {
		*m.addminutes_played += i
	} else {
		m.addminutes_played = &i
	}
}

// AddedMinutesPlayed returns the value that was added to the "minutes_played" field in this mutation.
func (m *MatchPlayerMutation) AddedMinutesPlayed() (r int32, exists bool) {
	v := m.addminutes_played
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinutesPlayed clears the value of the "minutes_played" field.
func (m *MatchPlayerMutation) ClearMinutesPlayed() {
	m.minutes_played = nil
	m.addminutes_played = nil
	m.clearedFields[matchplayer.FieldMinutesPlayed] = struct{}{}
}

// MinutesPlayedCleared returns if the "minutes_played" field was cleared in this mutation.
func (m *MatchPlayerMutation) MinutesPlayedCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldMinutesPlayed]
	return ok
}

// ResetMinutesPlayed resets all changes to the "minutes_played" field.
func (m *MatchPlayerMutation) ResetMinutesPlayed() {
	m.minutes_played = nil
	m.addminutes_played = nil
	delete(m.clearedFields, matchplayer.FieldMinutesPlayed)
}

// SetGoalsScored sets the "goals_scored" field.
func (m *MatchPlayerMutation) SetGoalsScored(i int32) {
	m.goals_scored = &i
	m.addgoals_scored = nil
}

// GoalsScored returns the value of the "goals_scored" field in the mutation.
func (m *MatchPlayerMutation) GoalsScored() (r int32, exists bool) {
	v := m.goals_scored
	if v == nil {
		return
	}
	return *v, true
}

// OldGoalsScored returns the old "goals_scored" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldGoalsScored(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGoalsScored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGoalsScored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGoalsScored: %w", err)
	}
	return oldValue.GoalsScored, nil
}

// AddGoalsScored adds i to the "goals_scored" field.
func (m *MatchPlayerMutation) AddGoalsScored(i int32) {
	if m.addgoals_scored != nil {
		*m.addgoals_scored += i
	} else {
		m.addgoals_scored = &i
	}
}

// AddedGoalsScored returns the value that was added to the "goals_scored" field in this mutation.
func (m *MatchPlayerMutation) AddedGoalsScored() (r int32, exists bool) {
	v := m.addgoals_scored
	if v == nil {
		return
	}
	return *v, true
}

// ClearGoalsScored clears the value of the "goals_scored" field.
func (m *MatchPlayerMutation) ClearGoalsScored() {
	m.goals_scored = nil
	m.addgoals_scored = nil
	m.clearedFields[matchplayer.FieldGoalsScored] = struct{}{}
}

// GoalsScoredCleared returns if the "goals_scored" field was cleared in this mutation.
func (m *MatchPlayerMutation) GoalsScoredCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldGoalsScored]
	return ok
}

// ResetGoalsScored resets all changes to the "goals_scored" field.
func (m *MatchPlayerMutation) ResetGoalsScored() {
	m.goals_scored = nil
	m.addgoals_scored = nil
	delete(m.clearedFields, matchplayer.FieldGoalsScored)
}

// SetAssists sets the "assists" field.
func (m *MatchPlayerMutation) SetAssists(i int32) {
	m.assists = &i
	m.addassists = nil
}

// Assists returns the value of the "assists" field in the mutation.
func (m *MatchPlayerMutation) Assists() (r int32, exists bool) {
	v := m.assists
	if v == nil {
		return
	}
	return *v, true
}

// OldAssists returns the old "assists" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldAssists(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAssists is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAssists requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAssists: %w", err)
	}
	return oldValue.Assists, nil
}

// AddAssists adds i to the "assists" field.
func (m *MatchPlayerMutation) AddAssists(i int32) {
	if m.addassists != nil {
		*m.addassists += i
	} else {
		m.addassists = &i
	}
}

// AddedAssists returns the value that was added to the "assists" field in this mutation.
func (m *MatchPlayerMutation) AddedAssists() (r int32, exists bool) {
	v := m.addassists
	if v == nil {
		return
	}
	return *v, true
}

// ClearAssists clears the value of the "assists" field.
func (m *MatchPlayerMutation) ClearAssists() {
	m.assists = nil
	m.addassists = nil
	m.clearedFields[matchplayer.FieldAssists] = struct{}{}
}

// AssistsCleared returns if the "assists" field was cleared in this mutation.
func (m *MatchPlayerMutation) AssistsCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldAssists]
	return ok
}

// ResetAssists resets all changes to the "assists" field.
func (m *MatchPlayerMutation) ResetAssists() {
	m.assists = nil
	m.addassists = nil
	delete(m.clearedFields, matchplayer.FieldAssists)
}

// SetYellowCards sets the "yellow_cards" field.
func (m *MatchPlayerMutation) SetYellowCards(i int32) {
	m.yellow_cards = &i
	m.addyellow_cards = nil
}

// YellowCards returns the value of the "yellow_cards" field in the mutation.
func (m *MatchPlayerMutation) YellowCards() (r int32, exists bool) {
	v := m.yellow_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldYellowCards returns the old "yellow_cards" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldYellowCards(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYellowCards is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYellowCards requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYellowCards: %w", err)
	}
	return oldValue.YellowCards, nil
}

// AddYellowCards adds i to the "yellow_cards" field.
func (m *MatchPlayerMutation) AddYellowCards(i int32) {
	if m.addyellow_cards != nil {
		*m.addyellow_cards += i
	} else {
		m.addyellow_cards = &i
	}
}

// AddedYellowCards returns the value that was added to the "yellow_cards" field in this mutation.
func (m *MatchPlayerMutation) AddedYellowCards() (r int32, exists bool) {
	v := m.addyellow_cards
	if v == nil {
		return
	}
	return *v, true
}

// ClearYellowCards clears the value of the "yellow_cards" field.
func (m *MatchPlayerMutation) ClearYellowCards() {
	m.yellow_cards = nil
	m.addyellow_cards = nil
	m.clearedFields[matchplayer.FieldYellowCards] = struct{}{}
}

// YellowCardsCleared returns if the "yellow_cards" field was cleared in this mutation.
func (m *MatchPlayerMutation) YellowCardsCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldYellowCards]
	return ok
}

// ResetYellowCards resets all changes to the "yellow_cards" field.
func (m *MatchPlayerMutation) ResetYellowCards() {
	m.yellow_cards = nil
	m.addyellow_cards = nil
	delete(m.clearedFields, matchplayer.FieldYellowCards)
}

// SetRedCard sets the "red_card" field.
func (m *MatchPlayerMutation) SetRedCard(b bool) {
	m.red_card = &b
}

// RedCard returns the value of the "red_card" field in the mutation.
func (m *MatchPlayerMutation) RedCard() (r bool, exists bool) {
	v := m.red_card
	if v == nil {
		return
	}
	return *v, true
}

// OldRedCard returns the old "red_card" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldRedCard(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedCard: %w", err)
	}
	return oldValue.RedCard, nil
}

// ClearRedCard clears the value of the "red_card" field.
func (m *MatchPlayerMutation) ClearRedCard() {
	m.red_card = nil
	m.clearedFields[matchplayer.FieldRedCard] = struct{}{}
}

// RedCardCleared returns if the "red_card" field was cleared in this mutation.
func (m *MatchPlayerMutation) RedCardCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldRedCard]
	return ok
}

// ResetRedCard resets all changes to the "red_card" field.
func (m *MatchPlayerMutation) ResetRedCard() {
	m.red_card = nil
	delete(m.clearedFields, matchplayer.FieldRedCard)
}

// SetCreatedAt sets the "created_at" field.
func (m *MatchPlayerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MatchPlayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MatchPlayerMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[matchplayer.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MatchPlayerMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MatchPlayerMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, matchplayer.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MatchPlayerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MatchPlayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MatchPlayer entity.
// If the MatchPlayer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MatchPlayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MatchPlayerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[matchplayer.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MatchPlayerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[matchplayer.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MatchPlayerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, matchplayer.FieldUpdatedAt)
}

// ClearMatch clears the "match" edge to the Match entity.
func (m *MatchPlayerMutation) ClearMatch() {
	m.clearedmatch = true
	m.clearedFields[matchplayer.FieldMatchID] = struct{}{}
}

// MatchCleared reports if the "match" edge to the Match entity was cleared.
func (m *MatchPlayerMutation) MatchCleared() bool {
	return m.MatchIDCleared() || m.clearedmatch
}

// MatchIDs returns the "match" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MatchID instead. It exists only for internal usage by the builders.
func (m *MatchPlayerMutation) MatchIDs() (ids []int32) {
	if id := m.match; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMatch resets all changes to the "match" edge.
func (m *MatchPlayerMutation) ResetMatch() {
	m.match = nil
	m.clearedmatch = false
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *MatchPlayerMutation) ClearPlayer() {
	m.clearedplayer = true
	m.clearedFields[matchplayer.FieldPlayerID] = struct{}{}
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *MatchPlayerMutation) PlayerCleared() bool {
	return m.PlayerIDCleared() || m.clearedplayer
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *MatchPlayerMutation) PlayerIDs() (ids []int32) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *MatchPlayerMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// Where appends a list predicates to the MatchPlayerMutation builder.
func (m *MatchPlayerMutation) Where(ps ...predicate.MatchPlayer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MatchPlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MatchPlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MatchPlayer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MatchPlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MatchPlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MatchPlayer).
func (m *MatchPlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MatchPlayerMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.match != nil {
		fields = append(fields, matchplayer.FieldMatchID)
	}
	if m.player != nil {
		fields = append(fields, matchplayer.FieldPlayerID)
	}
	if m.minutes_played != nil {
		fields = append(fields, matchplayer.FieldMinutesPlayed)
	}
	if m.goals_scored != nil {
		fields = append(fields, matchplayer.FieldGoalsScored)
	}
	if m.assists != nil {
		fields = append(fields, matchplayer.FieldAssists)
	}
	if m.yellow_cards != nil {
		fields = append(fields, matchplayer.FieldYellowCards)
	}
	if m.red_card != nil {
		fields = append(fields, matchplayer.FieldRedCard)
	}
	if m.created_at != nil {
		fields = append(fields, matchplayer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, matchplayer.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MatchPlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case matchplayer.FieldMatchID:
		return m.MatchID()
	case matchplayer.FieldPlayerID:
		return m.PlayerID()
	case matchplayer.FieldMinutesPlayed:
		return m.MinutesPlayed()
	case matchplayer.FieldGoalsScored:
		return m.GoalsScored()
	case matchplayer.FieldAssists:
		return m.Assists()
	case matchplayer.FieldYellowCards:
		return m.YellowCards()
	case matchplayer.FieldRedCard:
		return m.RedCard()
	case matchplayer.FieldCreatedAt:
		return m.CreatedAt()
	case matchplayer.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MatchPlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case matchplayer.FieldMatchID:
		return m.OldMatchID(ctx)
	case matchplayer.FieldPlayerID:
		return m.OldPlayerID(ctx)
	case matchplayer.FieldMinutesPlayed:
		return m.OldMinutesPlayed(ctx)
	case matchplayer.FieldGoalsScored:
		return m.OldGoalsScored(ctx)
	case matchplayer.FieldAssists:
		return m.OldAssists(ctx)
	case matchplayer.FieldYellowCards:
		return m.OldYellowCards(ctx)
	case matchplayer.FieldRedCard:
		return m.OldRedCard(ctx)
	case matchplayer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case matchplayer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown MatchPlayer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchPlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case matchplayer.FieldMatchID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMatchID(v)
		return nil
	case matchplayer.FieldPlayerID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerID(v)
		return nil
	case matchplayer.FieldMinutesPlayed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinutesPlayed(v)
		return nil
	case matchplayer.FieldGoalsScored:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGoalsScored(v)
		return nil
	case matchplayer.FieldAssists:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAssists(v)
		return nil
	case matchplayer.FieldYellowCards:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYellowCards(v)
		return nil
	case matchplayer.FieldRedCard:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedCard(v)
		return nil
	case matchplayer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case matchplayer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MatchPlayerMutation) AddedFields() []string {
	var fields []string
	if m.addminutes_played != nil {
		fields = append(fields, matchplayer.FieldMinutesPlayed)
	}
	if m.addgoals_scored != nil {
		fields = append(fields, matchplayer.FieldGoalsScored)
	}
	if m.addassists != nil {
		fields = append(fields, matchplayer.FieldAssists)
	}
	if m.addyellow_cards != nil {
		fields = append(fields, matchplayer.FieldYellowCards)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MatchPlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case matchplayer.FieldMinutesPlayed:
		return m.AddedMinutesPlayed()
	case matchplayer.FieldGoalsScored:
		return m.AddedGoalsScored()
	case matchplayer.FieldAssists:
		return m.AddedAssists()
	case matchplayer.FieldYellowCards:
		return m.AddedYellowCards()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MatchPlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case matchplayer.FieldMinutesPlayed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinutesPlayed(v)
		return nil
	case matchplayer.FieldGoalsScored:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGoalsScored(v)
		return nil
	case matchplayer.FieldAssists:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAssists(v)
		return nil
	case matchplayer.FieldYellowCards:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYellowCards(v)
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MatchPlayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(matchplayer.FieldMatchID) {
		fields = append(fields, matchplayer.FieldMatchID)
	}
	if m.FieldCleared(matchplayer.FieldPlayerID) {
		fields = append(fields, matchplayer.FieldPlayerID)
	}
	if m.FieldCleared(matchplayer.FieldMinutesPlayed) {
		fields = append(fields, matchplayer.FieldMinutesPlayed)
	}
	if m.FieldCleared(matchplayer.FieldGoalsScored) {
		fields = append(fields, matchplayer.FieldGoalsScored)
	}
	if m.FieldCleared(matchplayer.FieldAssists) {
		fields = append(fields, matchplayer.FieldAssists)
	}
	if m.FieldCleared(matchplayer.FieldYellowCards) {
		fields = append(fields, matchplayer.FieldYellowCards)
	}
	if m.FieldCleared(matchplayer.FieldRedCard) {
		fields = append(fields, matchplayer.FieldRedCard)
	}
	if m.FieldCleared(matchplayer.FieldCreatedAt) {
		fields = append(fields, matchplayer.FieldCreatedAt)
	}
	if m.FieldCleared(matchplayer.FieldUpdatedAt) {
		fields = append(fields, matchplayer.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MatchPlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MatchPlayerMutation) ClearField(name string) error {
	switch name {
	case matchplayer.FieldMatchID:
		m.ClearMatchID()
		return nil
	case matchplayer.FieldPlayerID:
		m.ClearPlayerID()
		return nil
	case matchplayer.FieldMinutesPlayed:
		m.ClearMinutesPlayed()
		return nil
	case matchplayer.FieldGoalsScored:
		m.ClearGoalsScored()
		return nil
	case matchplayer.FieldAssists:
		m.ClearAssists()
		return nil
	case matchplayer.FieldYellowCards:
		m.ClearYellowCards()
		return nil
	case matchplayer.FieldRedCard:
		m.ClearRedCard()
		return nil
	case matchplayer.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case matchplayer.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MatchPlayerMutation) ResetField(name string) error {
	switch name {
	case matchplayer.FieldMatchID:
		m.ResetMatchID()
		return nil
	case matchplayer.FieldPlayerID:
		m.ResetPlayerID()
		return nil
	case matchplayer.FieldMinutesPlayed:
		m.ResetMinutesPlayed()
		return nil
	case matchplayer.FieldGoalsScored:
		m.ResetGoalsScored()
		return nil
	case matchplayer.FieldAssists:
		m.ResetAssists()
		return nil
	case matchplayer.FieldYellowCards:
		m.ResetYellowCards()
		return nil
	case matchplayer.FieldRedCard:
		m.ResetRedCard()
		return nil
	case matchplayer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case matchplayer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MatchPlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.match != nil {
		edges = append(edges, matchplayer.EdgeMatch)
	}
	if m.player != nil {
		edges = append(edges, matchplayer.EdgePlayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MatchPlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case matchplayer.EdgeMatch:
		if id := m.match; id != nil {
			return []ent.Value{*id}
		}
	case matchplayer.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MatchPlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MatchPlayerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MatchPlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmatch {
		edges = append(edges, matchplayer.EdgeMatch)
	}
	if m.clearedplayer {
		edges = append(edges, matchplayer.EdgePlayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MatchPlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case matchplayer.EdgeMatch:
		return m.clearedmatch
	case matchplayer.EdgePlayer:
		return m.clearedplayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MatchPlayerMutation) ClearEdge(name string) error {
	switch name {
	case matchplayer.EdgeMatch:
		m.ClearMatch()
		return nil
	case matchplayer.EdgePlayer:
		m.ClearPlayer()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MatchPlayerMutation) ResetEdge(name string) error {
	switch name {
	case matchplayer.EdgeMatch:
		m.ResetMatch()
		return nil
	case matchplayer.EdgePlayer:
		m.ResetPlayer()
		return nil
	}
	return fmt.Errorf("unknown MatchPlayer edge %s", name)
}

// PlayerMutation represents an operation that mutates the Player nodes in the graph.
type PlayerMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int32
	full_name               *string
	jersey_number           *int32
	addjersey_number        *int32
	position                *string
	date_of_birth           *time.Time
	height_cm               *int32
	addheight_cm            *int32
	weight_kg               *int32
	addweight_kg            *int32
	phone                   *string
	email                   *string
	is_active               *bool
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	match_players           map[int32]struct{}
	removedmatch_players    map[int32]struct{}
	clearedmatch_players    bool
	player_statistic        *int32
	clearedplayer_statistic bool
	department              *int32
	cleareddepartment       bool
	done                    bool
	oldValue                func(context.Context) (*Player, error)
	predicates              []predicate.Player
}

var _ ent.Mutation = (*PlayerMutation)(nil)

// playerOption allows management of the mutation configuration using functional options.
type playerOption func(*PlayerMutation)

// newPlayerMutation creates new mutation for the Player entity.
func newPlayerMutation(c config, op Op, opts ...playerOption) *PlayerMutation {
	m := &PlayerMutation{
		config:        c,
		op:            op,
		typ:           TypePlayer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerID sets the ID field of the mutation.
func withPlayerID(id int32) playerOption {
	return func(m *PlayerMutation) {
		var (
			err   error
			once  sync.Once
			value *Player
		)
		m.oldValue = func(ctx context.Context) (*Player, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Player.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayer sets the old Player of the mutation.
func withPlayer(node *Player) playerOption {
	return func(m *PlayerMutation) {
		m.oldValue = func(context.Context) (*Player, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Player entities.
func (m *PlayerMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Player.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDepartmentID sets the "department_id" field.
func (m *PlayerMutation) SetDepartmentID(i int32) {
	m.department = &i
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *PlayerMutation) DepartmentID() (r int32, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldDepartmentID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *PlayerMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[player.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *PlayerMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[player.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *PlayerMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, player.FieldDepartmentID)
}

// SetFullName sets the "full_name" field.
func (m *PlayerMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *PlayerMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *PlayerMutation) ResetFullName() {
	m.full_name = nil
}

// SetJerseyNumber sets the "jersey_number" field.
func (m *PlayerMutation) SetJerseyNumber(i int32) {
	m.jersey_number = &i
	m.addjersey_number = nil
}

// JerseyNumber returns the value of the "jersey_number" field in the mutation.
func (m *PlayerMutation) JerseyNumber() (r int32, exists bool) {
	v := m.jersey_number
	if v == nil {
		return
	}
	return *v, true
}

// OldJerseyNumber returns the old "jersey_number" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldJerseyNumber(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJerseyNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJerseyNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJerseyNumber: %w", err)
	}
	return oldValue.JerseyNumber, nil
}

// AddJerseyNumber adds i to the "jersey_number" field.
func (m *PlayerMutation) AddJerseyNumber(i int32) {
	if m.addjersey_number != nil {
		*m.addjersey_number += i
	} else {
		m.addjersey_number = &i
	}
}

// AddedJerseyNumber returns the value that was added to the "jersey_number" field in this mutation.
func (m *PlayerMutation) AddedJerseyNumber() (r int32, exists bool) {
	v := m.addjersey_number
	if v == nil {
		return
	}
	return *v, true
}

// ClearJerseyNumber clears the value of the "jersey_number" field.
func (m *PlayerMutation) ClearJerseyNumber() {
	m.jersey_number = nil
	m.addjersey_number = nil
	m.clearedFields[player.FieldJerseyNumber] = struct{}{}
}

// JerseyNumberCleared returns if the "jersey_number" field was cleared in this mutation.
func (m *PlayerMutation) JerseyNumberCleared() bool {
	_, ok := m.clearedFields[player.FieldJerseyNumber]
	return ok
}

// ResetJerseyNumber resets all changes to the "jersey_number" field.
func (m *PlayerMutation) ResetJerseyNumber() {
	m.jersey_number = nil
	m.addjersey_number = nil
	delete(m.clearedFields, player.FieldJerseyNumber)
}

// SetPosition sets the "position" field.
func (m *PlayerMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the value of the "position" field in the mutation.
func (m *PlayerMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old "position" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPosition is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition resets all changes to the "position" field.
func (m *PlayerMutation) ResetPosition() {
	m.position = nil
}

// SetDateOfBirth sets the "date_of_birth" field.
func (m *PlayerMutation) SetDateOfBirth(t time.Time) {
	m.date_of_birth = &t
}

// DateOfBirth returns the value of the "date_of_birth" field in the mutation.
func (m *PlayerMutation) DateOfBirth() (r time.Time, exists bool) {
	v := m.date_of_birth
	if v == nil {
		return
	}
	return *v, true
}

// OldDateOfBirth returns the old "date_of_birth" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldDateOfBirth(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateOfBirth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateOfBirth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateOfBirth: %w", err)
	}
	return oldValue.DateOfBirth, nil
}

// ClearDateOfBirth clears the value of the "date_of_birth" field.
func (m *PlayerMutation) ClearDateOfBirth() {
	m.date_of_birth = nil
	m.clearedFields[player.FieldDateOfBirth] = struct{}{}
}

// DateOfBirthCleared returns if the "date_of_birth" field was cleared in this mutation.
func (m *PlayerMutation) DateOfBirthCleared() bool {
	_, ok := m.clearedFields[player.FieldDateOfBirth]
	return ok
}

// ResetDateOfBirth resets all changes to the "date_of_birth" field.
func (m *PlayerMutation) ResetDateOfBirth() {
	m.date_of_birth = nil
	delete(m.clearedFields, player.FieldDateOfBirth)
}

// SetHeightCm sets the "height_cm" field.
func (m *PlayerMutation) SetHeightCm(i int32) {
	m.height_cm = &i
	m.addheight_cm = nil
}

// HeightCm returns the value of the "height_cm" field in the mutation.
func (m *PlayerMutation) HeightCm() (r int32, exists bool) {
	v := m.height_cm
	if v == nil {
		return
	}
	return *v, true
}

// OldHeightCm returns the old "height_cm" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldHeightCm(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeightCm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeightCm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeightCm: %w", err)
	}
	return oldValue.HeightCm, nil
}

// AddHeightCm adds i to the "height_cm" field.
func (m *PlayerMutation) AddHeightCm(i int32) {
	if m.addheight_cm != nil {
		*m.addheight_cm += i
	} else {
		m.addheight_cm = &i
	}
}

// AddedHeightCm returns the value that was added to the "height_cm" field in this mutation.
func (m *PlayerMutation) AddedHeightCm() (r int32, exists bool) {
	v := m.addheight_cm
	if v == nil {
		return
	}
	return *v, true
}

// ClearHeightCm clears the value of the "height_cm" field.
func (m *PlayerMutation) ClearHeightCm() {
	m.height_cm = nil
	m.addheight_cm = nil
	m.clearedFields[player.FieldHeightCm] = struct{}{}
}

// HeightCmCleared returns if the "height_cm" field was cleared in this mutation.
func (m *PlayerMutation) HeightCmCleared() bool {
	_, ok := m.clearedFields[player.FieldHeightCm]
	return ok
}

// ResetHeightCm resets all changes to the "height_cm" field.
func (m *PlayerMutation) ResetHeightCm() {
	m.height_cm = nil
	m.addheight_cm = nil
	delete(m.clearedFields, player.FieldHeightCm)
}

// SetWeightKg sets the "weight_kg" field.
func (m *PlayerMutation) SetWeightKg(i int32) {
	m.weight_kg = &i
	m.addweight_kg = nil
}

// WeightKg returns the value of the "weight_kg" field in the mutation.
func (m *PlayerMutation) WeightKg() (r int32, exists bool) {
	v := m.weight_kg
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightKg returns the old "weight_kg" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldWeightKg(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeightKg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeightKg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightKg: %w", err)
	}
	return oldValue.WeightKg, nil
}

// AddWeightKg adds i to the "weight_kg" field.
func (m *PlayerMutation) AddWeightKg(i int32) {
	if m.addweight_kg != nil {
		*m.addweight_kg += i
	} else {
		m.addweight_kg = &i
	}
}

// AddedWeightKg returns the value that was added to the "weight_kg" field in this mutation.
func (m *PlayerMutation) AddedWeightKg() (r int32, exists bool) {
	v := m.addweight_kg
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeightKg clears the value of the "weight_kg" field.
func (m *PlayerMutation) ClearWeightKg() {
	m.weight_kg = nil
	m.addweight_kg = nil
	m.clearedFields[player.FieldWeightKg] = struct{}{}
}

// WeightKgCleared returns if the "weight_kg" field was cleared in this mutation.
func (m *PlayerMutation) WeightKgCleared() bool {
	_, ok := m.clearedFields[player.FieldWeightKg]
	return ok
}

// ResetWeightKg resets all changes to the "weight_kg" field.
func (m *PlayerMutation) ResetWeightKg() {
	m.weight_kg = nil
	m.addweight_kg = nil
	delete(m.clearedFields, player.FieldWeightKg)
}

// SetPhone sets the "phone" field.
func (m *PlayerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PlayerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *PlayerMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[player.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *PlayerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[player.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *PlayerMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, player.FieldPhone)
}

// SetEmail sets the "email" field.
func (m *PlayerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *PlayerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *PlayerMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[player.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *PlayerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[player.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *PlayerMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, player.FieldEmail)
}

// SetIsActive sets the "is_active" field.
func (m *PlayerMutation) SetIsActive(b bool) {
	m.is_active = &b
}

// IsActive returns the value of the "is_active" field in the mutation.
func (m *PlayerMutation) IsActive() (r bool, exists bool) {
	v := m.is_active
	if v == nil {
		return
	}
	return *v, true
}

// OldIsActive returns the old "is_active" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldIsActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsActive: %w", err)
	}
	return oldValue.IsActive, nil
}

// ClearIsActive clears the value of the "is_active" field.
func (m *PlayerMutation) ClearIsActive() {
	m.is_active = nil
	m.clearedFields[player.FieldIsActive] = struct{}{}
}

// IsActiveCleared returns if the "is_active" field was cleared in this mutation.
func (m *PlayerMutation) IsActiveCleared() bool {
	_, ok := m.clearedFields[player.FieldIsActive]
	return ok
}

// ResetIsActive resets all changes to the "is_active" field.
func (m *PlayerMutation) ResetIsActive() {
	m.is_active = nil
	delete(m.clearedFields, player.FieldIsActive)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlayerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlayerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PlayerMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[player.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PlayerMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[player.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlayerMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, player.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlayerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlayerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Player entity.
// If the Player object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PlayerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[player.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PlayerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[player.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlayerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, player.FieldUpdatedAt)
}

// AddMatchPlayerIDs adds the "match_players" edge to the MatchPlayer entity by ids.
func (m *PlayerMutation) AddMatchPlayerIDs(ids ...int32) {
	if m.match_players == nil {
		m.match_players = make(map[int32]struct{})
	}
	for i := range ids {
		m.match_players[ids[i]] = struct{}{}
	}
}

// ClearMatchPlayers clears the "match_players" edge to the MatchPlayer entity.
func (m *PlayerMutation) ClearMatchPlayers() {
	m.clearedmatch_players = true
}

// MatchPlayersCleared reports if the "match_players" edge to the MatchPlayer entity was cleared.
func (m *PlayerMutation) MatchPlayersCleared() bool {
	return m.clearedmatch_players
}

// RemoveMatchPlayerIDs removes the "match_players" edge to the MatchPlayer entity by IDs.
func (m *PlayerMutation) RemoveMatchPlayerIDs(ids ...int32) {
	if m.removedmatch_players == nil {
		m.removedmatch_players = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.match_players, ids[i])
		m.removedmatch_players[ids[i]] = struct{}{}
	}
}

// RemovedMatchPlayers returns the removed IDs of the "match_players" edge to the MatchPlayer entity.
func (m *PlayerMutation) RemovedMatchPlayersIDs() (ids []int32) {
	for id := range m.removedmatch_players {
		ids = append(ids, id)
	}
	return
}

// MatchPlayersIDs returns the "match_players" edge IDs in the mutation.
func (m *PlayerMutation) MatchPlayersIDs() (ids []int32) {
	for id := range m.match_players {
		ids = append(ids, id)
	}
	return
}

// ResetMatchPlayers resets all changes to the "match_players" edge.
func (m *PlayerMutation) ResetMatchPlayers() {
	m.match_players = nil
	m.clearedmatch_players = false
	m.removedmatch_players = nil
}

// SetPlayerStatisticID sets the "player_statistic" edge to the PlayerStatistic entity by id.
func (m *PlayerMutation) SetPlayerStatisticID(id int32) {
	m.player_statistic = &id
}

// ClearPlayerStatistic clears the "player_statistic" edge to the PlayerStatistic entity.
func (m *PlayerMutation) ClearPlayerStatistic() {
	m.clearedplayer_statistic = true
}

// PlayerStatisticCleared reports if the "player_statistic" edge to the PlayerStatistic entity was cleared.
func (m *PlayerMutation) PlayerStatisticCleared() bool {
	return m.clearedplayer_statistic
}

// PlayerStatisticID returns the "player_statistic" edge ID in the mutation.
func (m *PlayerMutation) PlayerStatisticID() (id int32, exists bool) {
	if m.player_statistic != nil {
		return *m.player_statistic, true
	}
	return
}

// PlayerStatisticIDs returns the "player_statistic" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerStatisticID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) PlayerStatisticIDs() (ids []int32) {
	if id := m.player_statistic; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayerStatistic resets all changes to the "player_statistic" edge.
func (m *PlayerMutation) ResetPlayerStatistic() {
	m.player_statistic = nil
	m.clearedplayer_statistic = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *PlayerMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[player.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *PlayerMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *PlayerMutation) DepartmentIDs() (ids []int32) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *PlayerMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Where appends a list predicates to the PlayerMutation builder.
func (m *PlayerMutation) Where(ps ...predicate.Player) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Player, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Player).
func (m *PlayerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.department != nil {
		fields = append(fields, player.FieldDepartmentID)
	}
	if m.full_name != nil {
		fields = append(fields, player.FieldFullName)
	}
	if m.jersey_number != nil {
		fields = append(fields, player.FieldJerseyNumber)
	}
	if m.position != nil {
		fields = append(fields, player.FieldPosition)
	}
	if m.date_of_birth != nil {
		fields = append(fields, player.FieldDateOfBirth)
	}
	if m.height_cm != nil {
		fields = append(fields, player.FieldHeightCm)
	}
	if m.weight_kg != nil {
		fields = append(fields, player.FieldWeightKg)
	}
	if m.phone != nil {
		fields = append(fields, player.FieldPhone)
	}
	if m.email != nil {
		fields = append(fields, player.FieldEmail)
	}
	if m.is_active != nil {
		fields = append(fields, player.FieldIsActive)
	}
	if m.created_at != nil {
		fields = append(fields, player.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, player.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case player.FieldDepartmentID:
		return m.DepartmentID()
	case player.FieldFullName:
		return m.FullName()
	case player.FieldJerseyNumber:
		return m.JerseyNumber()
	case player.FieldPosition:
		return m.Position()
	case player.FieldDateOfBirth:
		return m.DateOfBirth()
	case player.FieldHeightCm:
		return m.HeightCm()
	case player.FieldWeightKg:
		return m.WeightKg()
	case player.FieldPhone:
		return m.Phone()
	case player.FieldEmail:
		return m.Email()
	case player.FieldIsActive:
		return m.IsActive()
	case player.FieldCreatedAt:
		return m.CreatedAt()
	case player.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case player.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case player.FieldFullName:
		return m.OldFullName(ctx)
	case player.FieldJerseyNumber:
		return m.OldJerseyNumber(ctx)
	case player.FieldPosition:
		return m.OldPosition(ctx)
	case player.FieldDateOfBirth:
		return m.OldDateOfBirth(ctx)
	case player.FieldHeightCm:
		return m.OldHeightCm(ctx)
	case player.FieldWeightKg:
		return m.OldWeightKg(ctx)
	case player.FieldPhone:
		return m.OldPhone(ctx)
	case player.FieldEmail:
		return m.OldEmail(ctx)
	case player.FieldIsActive:
		return m.OldIsActive(ctx)
	case player.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case player.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Player field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case player.FieldDepartmentID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case player.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case player.FieldJerseyNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJerseyNumber(v)
		return nil
	case player.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	case player.FieldDateOfBirth:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateOfBirth(v)
		return nil
	case player.FieldHeightCm:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeightCm(v)
		return nil
	case player.FieldWeightKg:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightKg(v)
		return nil
	case player.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case player.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case player.FieldIsActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsActive(v)
		return nil
	case player.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case player.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerMutation) AddedFields() []string {
	var fields []string
	if m.addjersey_number != nil {
		fields = append(fields, player.FieldJerseyNumber)
	}
	if m.addheight_cm != nil {
		fields = append(fields, player.FieldHeightCm)
	}
	if m.addweight_kg != nil {
		fields = append(fields, player.FieldWeightKg)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case player.FieldJerseyNumber:
		return m.AddedJerseyNumber()
	case player.FieldHeightCm:
		return m.AddedHeightCm()
	case player.FieldWeightKg:
		return m.AddedWeightKg()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case player.FieldJerseyNumber:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJerseyNumber(v)
		return nil
	case player.FieldHeightCm:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeightCm(v)
		return nil
	case player.FieldWeightKg:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightKg(v)
		return nil
	}
	return fmt.Errorf("unknown Player numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(player.FieldDepartmentID) {
		fields = append(fields, player.FieldDepartmentID)
	}
	if m.FieldCleared(player.FieldJerseyNumber) {
		fields = append(fields, player.FieldJerseyNumber)
	}
	if m.FieldCleared(player.FieldDateOfBirth) {
		fields = append(fields, player.FieldDateOfBirth)
	}
	if m.FieldCleared(player.FieldHeightCm) {
		fields = append(fields, player.FieldHeightCm)
	}
	if m.FieldCleared(player.FieldWeightKg) {
		fields = append(fields, player.FieldWeightKg)
	}
	if m.FieldCleared(player.FieldPhone) {
		fields = append(fields, player.FieldPhone)
	}
	if m.FieldCleared(player.FieldEmail) {
		fields = append(fields, player.FieldEmail)
	}
	if m.FieldCleared(player.FieldIsActive) {
		fields = append(fields, player.FieldIsActive)
	}
	if m.FieldCleared(player.FieldCreatedAt) {
		fields = append(fields, player.FieldCreatedAt)
	}
	if m.FieldCleared(player.FieldUpdatedAt) {
		fields = append(fields, player.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerMutation) ClearField(name string) error {
	switch name {
	case player.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case player.FieldJerseyNumber:
		m.ClearJerseyNumber()
		return nil
	case player.FieldDateOfBirth:
		m.ClearDateOfBirth()
		return nil
	case player.FieldHeightCm:
		m.ClearHeightCm()
		return nil
	case player.FieldWeightKg:
		m.ClearWeightKg()
		return nil
	case player.FieldPhone:
		m.ClearPhone()
		return nil
	case player.FieldEmail:
		m.ClearEmail()
		return nil
	case player.FieldIsActive:
		m.ClearIsActive()
		return nil
	case player.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case player.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Player nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerMutation) ResetField(name string) error {
	switch name {
	case player.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case player.FieldFullName:
		m.ResetFullName()
		return nil
	case player.FieldJerseyNumber:
		m.ResetJerseyNumber()
		return nil
	case player.FieldPosition:
		m.ResetPosition()
		return nil
	case player.FieldDateOfBirth:
		m.ResetDateOfBirth()
		return nil
	case player.FieldHeightCm:
		m.ResetHeightCm()
		return nil
	case player.FieldWeightKg:
		m.ResetWeightKg()
		return nil
	case player.FieldPhone:
		m.ResetPhone()
		return nil
	case player.FieldEmail:
		m.ResetEmail()
		return nil
	case player.FieldIsActive:
		m.ResetIsActive()
		return nil
	case player.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case player.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Player field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.match_players != nil {
		edges = append(edges, player.EdgeMatchPlayers)
	}
	if m.player_statistic != nil {
		edges = append(edges, player.EdgePlayerStatistic)
	}
	if m.department != nil {
		edges = append(edges, player.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeMatchPlayers:
		ids := make([]ent.Value, 0, len(m.match_players))
		for id := range m.match_players {
			ids = append(ids, id)
		}
		return ids
	case player.EdgePlayerStatistic:
		if id := m.player_statistic; id != nil {
			return []ent.Value{*id}
		}
	case player.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmatch_players != nil {
		edges = append(edges, player.EdgeMatchPlayers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case player.EdgeMatchPlayers:
		ids := make([]ent.Value, 0, len(m.removedmatch_players))
		for id := range m.removedmatch_players {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmatch_players {
		edges = append(edges, player.EdgeMatchPlayers)
	}
	if m.clearedplayer_statistic {
		edges = append(edges, player.EdgePlayerStatistic)
	}
	if m.cleareddepartment {
		edges = append(edges, player.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerMutation) EdgeCleared(name string) bool {
	switch name {
	case player.EdgeMatchPlayers:
		return m.clearedmatch_players
	case player.EdgePlayerStatistic:
		return m.clearedplayer_statistic
	case player.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerMutation) ClearEdge(name string) error {
	switch name {
	case player.EdgePlayerStatistic:
		m.ClearPlayerStatistic()
		return nil
	case player.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown Player unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerMutation) ResetEdge(name string) error {
	switch name {
	case player.EdgeMatchPlayers:
		m.ResetMatchPlayers()
		return nil
	case player.EdgePlayerStatistic:
		m.ResetPlayerStatistic()
		return nil
	case player.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Player edge %s", name)
}

// PlayerStatisticMutation represents an operation that mutates the PlayerStatistic nodes in the graph.
type PlayerStatisticMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int32
	total_matches           *int32
	addtotal_matches        *int32
	total_minutes_played    *int32
	addtotal_minutes_played *int32
	total_goals             *int32
	addtotal_goals          *int32
	total_assists           *int32
	addtotal_assists        *int32
	total_yellow_cards      *int32
	addtotal_yellow_cards   *int32
	total_red_cards         *int32
	addtotal_red_cards      *int32
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	player                  *int32
	clearedplayer           bool
	done                    bool
	oldValue                func(context.Context) (*PlayerStatistic, error)
	predicates              []predicate.PlayerStatistic
}

var _ ent.Mutation = (*PlayerStatisticMutation)(nil)

// playerstatisticOption allows management of the mutation configuration using functional options.
type playerstatisticOption func(*PlayerStatisticMutation)

// newPlayerStatisticMutation creates new mutation for the PlayerStatistic entity.
func newPlayerStatisticMutation(c config, op Op, opts ...playerstatisticOption) *PlayerStatisticMutation {
	m := &PlayerStatisticMutation{
		config:        c,
		op:            op,
		typ:           TypePlayerStatistic,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlayerStatisticID sets the ID field of the mutation.
func withPlayerStatisticID(id int32) playerstatisticOption {
	return func(m *PlayerStatisticMutation) {
		var (
			err   error
			once  sync.Once
			value *PlayerStatistic
		)
		m.oldValue = func(ctx context.Context) (*PlayerStatistic, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlayerStatistic.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlayerStatistic sets the old PlayerStatistic of the mutation.
func withPlayerStatistic(node *PlayerStatistic) playerstatisticOption {
	return func(m *PlayerStatisticMutation) {
		m.oldValue = func(context.Context) (*PlayerStatistic, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlayerStatisticMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlayerStatisticMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlayerStatistic entities.
func (m *PlayerStatisticMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlayerStatisticMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlayerStatisticMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlayerStatistic.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPlayerID sets the "player_id" field.
func (m *PlayerStatisticMutation) SetPlayerID(i int32) {
	m.player = &i
}

// PlayerID returns the value of the "player_id" field in the mutation.
func (m *PlayerStatisticMutation) PlayerID() (r int32, exists bool) {
	v := m.player
	if v == nil {
		return
	}
	return *v, true
}

// OldPlayerID returns the old "player_id" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldPlayerID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlayerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlayerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlayerID: %w", err)
	}
	return oldValue.PlayerID, nil
}

// ClearPlayerID clears the value of the "player_id" field.
func (m *PlayerStatisticMutation) ClearPlayerID() {
	m.player = nil
	m.clearedFields[playerstatistic.FieldPlayerID] = struct{}{}
}

// PlayerIDCleared returns if the "player_id" field was cleared in this mutation.
func (m *PlayerStatisticMutation) PlayerIDCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldPlayerID]
	return ok
}

// ResetPlayerID resets all changes to the "player_id" field.
func (m *PlayerStatisticMutation) ResetPlayerID() {
	m.player = nil
	delete(m.clearedFields, playerstatistic.FieldPlayerID)
}

// SetTotalMatches sets the "total_matches" field.
func (m *PlayerStatisticMutation) SetTotalMatches(i int32) {
	m.total_matches = &i
	m.addtotal_matches = nil
}

// TotalMatches returns the value of the "total_matches" field in the mutation.
func (m *PlayerStatisticMutation) TotalMatches() (r int32, exists bool) {
	v := m.total_matches
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMatches returns the old "total_matches" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldTotalMatches(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMatches is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMatches requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMatches: %w", err)
	}
	return oldValue.TotalMatches, nil
}

// AddTotalMatches adds i to the "total_matches" field.
func (m *PlayerStatisticMutation) AddTotalMatches(i int32) {
	if m.addtotal_matches != nil {
		*m.addtotal_matches += i
	} else {
		m.addtotal_matches = &i
	}
}

// AddedTotalMatches returns the value that was added to the "total_matches" field in this mutation.
func (m *PlayerStatisticMutation) AddedTotalMatches() (r int32, exists bool) {
	v := m.addtotal_matches
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalMatches clears the value of the "total_matches" field.
func (m *PlayerStatisticMutation) ClearTotalMatches() {
	m.total_matches = nil
	m.addtotal_matches = nil
	m.clearedFields[playerstatistic.FieldTotalMatches] = struct{}{}
}

// TotalMatchesCleared returns if the "total_matches" field was cleared in this mutation.
func (m *PlayerStatisticMutation) TotalMatchesCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldTotalMatches]
	return ok
}

// ResetTotalMatches resets all changes to the "total_matches" field.
func (m *PlayerStatisticMutation) ResetTotalMatches() {
	m.total_matches = nil
	m.addtotal_matches = nil
	delete(m.clearedFields, playerstatistic.FieldTotalMatches)
}

// SetTotalMinutesPlayed sets the "total_minutes_played" field.
func (m *PlayerStatisticMutation) SetTotalMinutesPlayed(i int32) {
	m.total_minutes_played = &i
	m.addtotal_minutes_played = nil
}

// TotalMinutesPlayed returns the value of the "total_minutes_played" field in the mutation.
func (m *PlayerStatisticMutation) TotalMinutesPlayed() (r int32, exists bool) {
	v := m.total_minutes_played
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMinutesPlayed returns the old "total_minutes_played" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldTotalMinutesPlayed(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMinutesPlayed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMinutesPlayed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMinutesPlayed: %w", err)
	}
	return oldValue.TotalMinutesPlayed, nil
}

// AddTotalMinutesPlayed adds i to the "total_minutes_played" field.
func (m *PlayerStatisticMutation) AddTotalMinutesPlayed(i int32) {
	if m.addtotal_minutes_played != nil {
		*m.addtotal_minutes_played += i
	} else {
		m.addtotal_minutes_played = &i
	}
}

// AddedTotalMinutesPlayed returns the value that was added to the "total_minutes_played" field in this mutation.
func (m *PlayerStatisticMutation) AddedTotalMinutesPlayed() (r int32, exists bool) {
	v := m.addtotal_minutes_played
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalMinutesPlayed clears the value of the "total_minutes_played" field.
func (m *PlayerStatisticMutation) ClearTotalMinutesPlayed() {
	m.total_minutes_played = nil
	m.addtotal_minutes_played = nil
	m.clearedFields[playerstatistic.FieldTotalMinutesPlayed] = struct{}{}
}

// TotalMinutesPlayedCleared returns if the "total_minutes_played" field was cleared in this mutation.
func (m *PlayerStatisticMutation) TotalMinutesPlayedCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldTotalMinutesPlayed]
	return ok
}

// ResetTotalMinutesPlayed resets all changes to the "total_minutes_played" field.
func (m *PlayerStatisticMutation) ResetTotalMinutesPlayed() {
	m.total_minutes_played = nil
	m.addtotal_minutes_played = nil
	delete(m.clearedFields, playerstatistic.FieldTotalMinutesPlayed)
}

// SetTotalGoals sets the "total_goals" field.
func (m *PlayerStatisticMutation) SetTotalGoals(i int32) {
	m.total_goals = &i
	m.addtotal_goals = nil
}

// TotalGoals returns the value of the "total_goals" field in the mutation.
func (m *PlayerStatisticMutation) TotalGoals() (r int32, exists bool) {
	v := m.total_goals
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalGoals returns the old "total_goals" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldTotalGoals(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalGoals is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalGoals requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalGoals: %w", err)
	}
	return oldValue.TotalGoals, nil
}

// AddTotalGoals adds i to the "total_goals" field.
func (m *PlayerStatisticMutation) AddTotalGoals(i int32) {
	if m.addtotal_goals != nil {
		*m.addtotal_goals += i
	} else {
		m.addtotal_goals = &i
	}
}

// AddedTotalGoals returns the value that was added to the "total_goals" field in this mutation.
func (m *PlayerStatisticMutation) AddedTotalGoals() (r int32, exists bool) {
	v := m.addtotal_goals
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalGoals clears the value of the "total_goals" field.
func (m *PlayerStatisticMutation) ClearTotalGoals() {
	m.total_goals = nil
	m.addtotal_goals = nil
	m.clearedFields[playerstatistic.FieldTotalGoals] = struct{}{}
}

// TotalGoalsCleared returns if the "total_goals" field was cleared in this mutation.
func (m *PlayerStatisticMutation) TotalGoalsCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldTotalGoals]
	return ok
}

// ResetTotalGoals resets all changes to the "total_goals" field.
func (m *PlayerStatisticMutation) ResetTotalGoals() {
	m.total_goals = nil
	m.addtotal_goals = nil
	delete(m.clearedFields, playerstatistic.FieldTotalGoals)
}

// SetTotalAssists sets the "total_assists" field.
func (m *PlayerStatisticMutation) SetTotalAssists(i int32) {
	m.total_assists = &i
	m.addtotal_assists = nil
}

// TotalAssists returns the value of the "total_assists" field in the mutation.
func (m *PlayerStatisticMutation) TotalAssists() (r int32, exists bool) {
	v := m.total_assists
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAssists returns the old "total_assists" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldTotalAssists(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAssists is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAssists requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAssists: %w", err)
	}
	return oldValue.TotalAssists, nil
}

// AddTotalAssists adds i to the "total_assists" field.
func (m *PlayerStatisticMutation) AddTotalAssists(i int32) {
	if m.addtotal_assists != nil {
		*m.addtotal_assists += i
	} else {
		m.addtotal_assists = &i
	}
}

// AddedTotalAssists returns the value that was added to the "total_assists" field in this mutation.
func (m *PlayerStatisticMutation) AddedTotalAssists() (r int32, exists bool) {
	v := m.addtotal_assists
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalAssists clears the value of the "total_assists" field.
func (m *PlayerStatisticMutation) ClearTotalAssists() {
	m.total_assists = nil
	m.addtotal_assists = nil
	m.clearedFields[playerstatistic.FieldTotalAssists] = struct{}{}
}

// TotalAssistsCleared returns if the "total_assists" field was cleared in this mutation.
func (m *PlayerStatisticMutation) TotalAssistsCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldTotalAssists]
	return ok
}

// ResetTotalAssists resets all changes to the "total_assists" field.
func (m *PlayerStatisticMutation) ResetTotalAssists() {
	m.total_assists = nil
	m.addtotal_assists = nil
	delete(m.clearedFields, playerstatistic.FieldTotalAssists)
}

// SetTotalYellowCards sets the "total_yellow_cards" field.
func (m *PlayerStatisticMutation) SetTotalYellowCards(i int32) {
	m.total_yellow_cards = &i
	m.addtotal_yellow_cards = nil
}

// TotalYellowCards returns the value of the "total_yellow_cards" field in the mutation.
func (m *PlayerStatisticMutation) TotalYellowCards() (r int32, exists bool) {
	v := m.total_yellow_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalYellowCards returns the old "total_yellow_cards" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldTotalYellowCards(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalYellowCards is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalYellowCards requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalYellowCards: %w", err)
	}
	return oldValue.TotalYellowCards, nil
}

// AddTotalYellowCards adds i to the "total_yellow_cards" field.
func (m *PlayerStatisticMutation) AddTotalYellowCards(i int32) {
	if m.addtotal_yellow_cards != nil {
		*m.addtotal_yellow_cards += i
	} else {
		m.addtotal_yellow_cards = &i
	}
}

// AddedTotalYellowCards returns the value that was added to the "total_yellow_cards" field in this mutation.
func (m *PlayerStatisticMutation) AddedTotalYellowCards() (r int32, exists bool) {
	v := m.addtotal_yellow_cards
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalYellowCards clears the value of the "total_yellow_cards" field.
func (m *PlayerStatisticMutation) ClearTotalYellowCards() {
	m.total_yellow_cards = nil
	m.addtotal_yellow_cards = nil
	m.clearedFields[playerstatistic.FieldTotalYellowCards] = struct{}{}
}

// TotalYellowCardsCleared returns if the "total_yellow_cards" field was cleared in this mutation.
func (m *PlayerStatisticMutation) TotalYellowCardsCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldTotalYellowCards]
	return ok
}

// ResetTotalYellowCards resets all changes to the "total_yellow_cards" field.
func (m *PlayerStatisticMutation) ResetTotalYellowCards() {
	m.total_yellow_cards = nil
	m.addtotal_yellow_cards = nil
	delete(m.clearedFields, playerstatistic.FieldTotalYellowCards)
}

// SetTotalRedCards sets the "total_red_cards" field.
func (m *PlayerStatisticMutation) SetTotalRedCards(i int32) {
	m.total_red_cards = &i
	m.addtotal_red_cards = nil
}

// TotalRedCards returns the value of the "total_red_cards" field in the mutation.
func (m *PlayerStatisticMutation) TotalRedCards() (r int32, exists bool) {
	v := m.total_red_cards
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRedCards returns the old "total_red_cards" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldTotalRedCards(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRedCards is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRedCards requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRedCards: %w", err)
	}
	return oldValue.TotalRedCards, nil
}

// AddTotalRedCards adds i to the "total_red_cards" field.
func (m *PlayerStatisticMutation) AddTotalRedCards(i int32) {
	if m.addtotal_red_cards != nil {
		*m.addtotal_red_cards += i
	} else {
		m.addtotal_red_cards = &i
	}
}

// AddedTotalRedCards returns the value that was added to the "total_red_cards" field in this mutation.
func (m *PlayerStatisticMutation) AddedTotalRedCards() (r int32, exists bool) {
	v := m.addtotal_red_cards
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalRedCards clears the value of the "total_red_cards" field.
func (m *PlayerStatisticMutation) ClearTotalRedCards() {
	m.total_red_cards = nil
	m.addtotal_red_cards = nil
	m.clearedFields[playerstatistic.FieldTotalRedCards] = struct{}{}
}

// TotalRedCardsCleared returns if the "total_red_cards" field was cleared in this mutation.
func (m *PlayerStatisticMutation) TotalRedCardsCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldTotalRedCards]
	return ok
}

// ResetTotalRedCards resets all changes to the "total_red_cards" field.
func (m *PlayerStatisticMutation) ResetTotalRedCards() {
	m.total_red_cards = nil
	m.addtotal_red_cards = nil
	delete(m.clearedFields, playerstatistic.FieldTotalRedCards)
}

// SetCreatedAt sets the "created_at" field.
func (m *PlayerStatisticMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlayerStatisticMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PlayerStatisticMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[playerstatistic.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PlayerStatisticMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlayerStatisticMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, playerstatistic.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlayerStatisticMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlayerStatisticMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PlayerStatistic entity.
// If the PlayerStatistic object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlayerStatisticMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PlayerStatisticMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[playerstatistic.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PlayerStatisticMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[playerstatistic.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlayerStatisticMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, playerstatistic.FieldUpdatedAt)
}

// ClearPlayer clears the "player" edge to the Player entity.
func (m *PlayerStatisticMutation) ClearPlayer() {
	m.clearedplayer = true
	m.clearedFields[playerstatistic.FieldPlayerID] = struct{}{}
}

// PlayerCleared reports if the "player" edge to the Player entity was cleared.
func (m *PlayerStatisticMutation) PlayerCleared() bool {
	return m.PlayerIDCleared() || m.clearedplayer
}

// PlayerIDs returns the "player" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlayerID instead. It exists only for internal usage by the builders.
func (m *PlayerStatisticMutation) PlayerIDs() (ids []int32) {
	if id := m.player; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlayer resets all changes to the "player" edge.
func (m *PlayerStatisticMutation) ResetPlayer() {
	m.player = nil
	m.clearedplayer = false
}

// Where appends a list predicates to the PlayerStatisticMutation builder.
func (m *PlayerStatisticMutation) Where(ps ...predicate.PlayerStatistic) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlayerStatisticMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlayerStatisticMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlayerStatistic, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlayerStatisticMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlayerStatisticMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlayerStatistic).
func (m *PlayerStatisticMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlayerStatisticMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.player != nil {
		fields = append(fields, playerstatistic.FieldPlayerID)
	}
	if m.total_matches != nil {
		fields = append(fields, playerstatistic.FieldTotalMatches)
	}
	if m.total_minutes_played != nil {
		fields = append(fields, playerstatistic.FieldTotalMinutesPlayed)
	}
	if m.total_goals != nil {
		fields = append(fields, playerstatistic.FieldTotalGoals)
	}
	if m.total_assists != nil {
		fields = append(fields, playerstatistic.FieldTotalAssists)
	}
	if m.total_yellow_cards != nil {
		fields = append(fields, playerstatistic.FieldTotalYellowCards)
	}
	if m.total_red_cards != nil {
		fields = append(fields, playerstatistic.FieldTotalRedCards)
	}
	if m.created_at != nil {
		fields = append(fields, playerstatistic.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, playerstatistic.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlayerStatisticMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case playerstatistic.FieldPlayerID:
		return m.PlayerID()
	case playerstatistic.FieldTotalMatches:
		return m.TotalMatches()
	case playerstatistic.FieldTotalMinutesPlayed:
		return m.TotalMinutesPlayed()
	case playerstatistic.FieldTotalGoals:
		return m.TotalGoals()
	case playerstatistic.FieldTotalAssists:
		return m.TotalAssists()
	case playerstatistic.FieldTotalYellowCards:
		return m.TotalYellowCards()
	case playerstatistic.FieldTotalRedCards:
		return m.TotalRedCards()
	case playerstatistic.FieldCreatedAt:
		return m.CreatedAt()
	case playerstatistic.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlayerStatisticMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case playerstatistic.FieldPlayerID:
		return m.OldPlayerID(ctx)
	case playerstatistic.FieldTotalMatches:
		return m.OldTotalMatches(ctx)
	case playerstatistic.FieldTotalMinutesPlayed:
		return m.OldTotalMinutesPlayed(ctx)
	case playerstatistic.FieldTotalGoals:
		return m.OldTotalGoals(ctx)
	case playerstatistic.FieldTotalAssists:
		return m.OldTotalAssists(ctx)
	case playerstatistic.FieldTotalYellowCards:
		return m.OldTotalYellowCards(ctx)
	case playerstatistic.FieldTotalRedCards:
		return m.OldTotalRedCards(ctx)
	case playerstatistic.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case playerstatistic.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PlayerStatistic field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerStatisticMutation) SetField(name string, value ent.Value) error {
	switch name {
	case playerstatistic.FieldPlayerID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlayerID(v)
		return nil
	case playerstatistic.FieldTotalMatches:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMatches(v)
		return nil
	case playerstatistic.FieldTotalMinutesPlayed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMinutesPlayed(v)
		return nil
	case playerstatistic.FieldTotalGoals:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalGoals(v)
		return nil
	case playerstatistic.FieldTotalAssists:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAssists(v)
		return nil
	case playerstatistic.FieldTotalYellowCards:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalYellowCards(v)
		return nil
	case playerstatistic.FieldTotalRedCards:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRedCards(v)
		return nil
	case playerstatistic.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case playerstatistic.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerStatistic field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlayerStatisticMutation) AddedFields() []string {
	var fields []string
	if m.addtotal_matches != nil {
		fields = append(fields, playerstatistic.FieldTotalMatches)
	}
	if m.addtotal_minutes_played != nil {
		fields = append(fields, playerstatistic.FieldTotalMinutesPlayed)
	}
	if m.addtotal_goals != nil {
		fields = append(fields, playerstatistic.FieldTotalGoals)
	}
	if m.addtotal_assists != nil {
		fields = append(fields, playerstatistic.FieldTotalAssists)
	}
	if m.addtotal_yellow_cards != nil {
		fields = append(fields, playerstatistic.FieldTotalYellowCards)
	}
	if m.addtotal_red_cards != nil {
		fields = append(fields, playerstatistic.FieldTotalRedCards)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlayerStatisticMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case playerstatistic.FieldTotalMatches:
		return m.AddedTotalMatches()
	case playerstatistic.FieldTotalMinutesPlayed:
		return m.AddedTotalMinutesPlayed()
	case playerstatistic.FieldTotalGoals:
		return m.AddedTotalGoals()
	case playerstatistic.FieldTotalAssists:
		return m.AddedTotalAssists()
	case playerstatistic.FieldTotalYellowCards:
		return m.AddedTotalYellowCards()
	case playerstatistic.FieldTotalRedCards:
		return m.AddedTotalRedCards()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlayerStatisticMutation) AddField(name string, value ent.Value) error {
	switch name {
	case playerstatistic.FieldTotalMatches:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMatches(v)
		return nil
	case playerstatistic.FieldTotalMinutesPlayed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMinutesPlayed(v)
		return nil
	case playerstatistic.FieldTotalGoals:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalGoals(v)
		return nil
	case playerstatistic.FieldTotalAssists:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalAssists(v)
		return nil
	case playerstatistic.FieldTotalYellowCards:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalYellowCards(v)
		return nil
	case playerstatistic.FieldTotalRedCards:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRedCards(v)
		return nil
	}
	return fmt.Errorf("unknown PlayerStatistic numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlayerStatisticMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(playerstatistic.FieldPlayerID) {
		fields = append(fields, playerstatistic.FieldPlayerID)
	}
	if m.FieldCleared(playerstatistic.FieldTotalMatches) {
		fields = append(fields, playerstatistic.FieldTotalMatches)
	}
	if m.FieldCleared(playerstatistic.FieldTotalMinutesPlayed) {
		fields = append(fields, playerstatistic.FieldTotalMinutesPlayed)
	}
	if m.FieldCleared(playerstatistic.FieldTotalGoals) {
		fields = append(fields, playerstatistic.FieldTotalGoals)
	}
	if m.FieldCleared(playerstatistic.FieldTotalAssists) {
		fields = append(fields, playerstatistic.FieldTotalAssists)
	}
	if m.FieldCleared(playerstatistic.FieldTotalYellowCards) {
		fields = append(fields, playerstatistic.FieldTotalYellowCards)
	}
	if m.FieldCleared(playerstatistic.FieldTotalRedCards) {
		fields = append(fields, playerstatistic.FieldTotalRedCards)
	}
	if m.FieldCleared(playerstatistic.FieldCreatedAt) {
		fields = append(fields, playerstatistic.FieldCreatedAt)
	}
	if m.FieldCleared(playerstatistic.FieldUpdatedAt) {
		fields = append(fields, playerstatistic.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlayerStatisticMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlayerStatisticMutation) ClearField(name string) error {
	switch name {
	case playerstatistic.FieldPlayerID:
		m.ClearPlayerID()
		return nil
	case playerstatistic.FieldTotalMatches:
		m.ClearTotalMatches()
		return nil
	case playerstatistic.FieldTotalMinutesPlayed:
		m.ClearTotalMinutesPlayed()
		return nil
	case playerstatistic.FieldTotalGoals:
		m.ClearTotalGoals()
		return nil
	case playerstatistic.FieldTotalAssists:
		m.ClearTotalAssists()
		return nil
	case playerstatistic.FieldTotalYellowCards:
		m.ClearTotalYellowCards()
		return nil
	case playerstatistic.FieldTotalRedCards:
		m.ClearTotalRedCards()
		return nil
	case playerstatistic.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case playerstatistic.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PlayerStatistic nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlayerStatisticMutation) ResetField(name string) error {
	switch name {
	case playerstatistic.FieldPlayerID:
		m.ResetPlayerID()
		return nil
	case playerstatistic.FieldTotalMatches:
		m.ResetTotalMatches()
		return nil
	case playerstatistic.FieldTotalMinutesPlayed:
		m.ResetTotalMinutesPlayed()
		return nil
	case playerstatistic.FieldTotalGoals:
		m.ResetTotalGoals()
		return nil
	case playerstatistic.FieldTotalAssists:
		m.ResetTotalAssists()
		return nil
	case playerstatistic.FieldTotalYellowCards:
		m.ResetTotalYellowCards()
		return nil
	case playerstatistic.FieldTotalRedCards:
		m.ResetTotalRedCards()
		return nil
	case playerstatistic.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case playerstatistic.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown PlayerStatistic field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlayerStatisticMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.player != nil {
		edges = append(edges, playerstatistic.EdgePlayer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlayerStatisticMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case playerstatistic.EdgePlayer:
		if id := m.player; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlayerStatisticMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlayerStatisticMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlayerStatisticMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplayer {
		edges = append(edges, playerstatistic.EdgePlayer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlayerStatisticMutation) EdgeCleared(name string) bool {
	switch name {
	case playerstatistic.EdgePlayer:
		return m.clearedplayer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlayerStatisticMutation) ClearEdge(name string) error {
	switch name {
	case playerstatistic.EdgePlayer:
		m.ClearPlayer()
		return nil
	}
	return fmt.Errorf("unknown PlayerStatistic unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlayerStatisticMutation) ResetEdge(name string) error {
	switch name {
	case playerstatistic.EdgePlayer:
		m.ResetPlayer()
		return nil
	}
	return fmt.Errorf("unknown PlayerStatistic edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op             Op
	typ            string
	id             *int32
	name           *string
	company_name   *string
	contact_person *string
	contact_phone  *string
	contact_email  *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	matches        map[int32]struct{}
	removedmatches map[int32]struct{}
	clearedmatches bool
	done           bool
	oldValue       func(context.Context) (*Team, error)
	predicates     []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id int32) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetCompanyName sets the "company_name" field.
func (m *TeamMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *TeamMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ClearCompanyName clears the value of the "company_name" field.
func (m *TeamMutation) ClearCompanyName() {
	m.company_name = nil
	m.clearedFields[team.FieldCompanyName] = struct{}{}
}

// CompanyNameCleared returns if the "company_name" field was cleared in this mutation.
func (m *TeamMutation) CompanyNameCleared() bool {
	_, ok := m.clearedFields[team.FieldCompanyName]
	return ok
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *TeamMutation) ResetCompanyName() {
	m.company_name = nil
	delete(m.clearedFields, team.FieldCompanyName)
}

// SetContactPerson sets the "contact_person" field.
func (m *TeamMutation) SetContactPerson(s string) {
	m.contact_person = &s
}

// ContactPerson returns the value of the "contact_person" field in the mutation.
func (m *TeamMutation) ContactPerson() (r string, exists bool) {
	v := m.contact_person
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPerson returns the old "contact_person" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldContactPerson(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPerson: %w", err)
	}
	return oldValue.ContactPerson, nil
}

// ClearContactPerson clears the value of the "contact_person" field.
func (m *TeamMutation) ClearContactPerson() {
	m.contact_person = nil
	m.clearedFields[team.FieldContactPerson] = struct{}{}
}

// ContactPersonCleared returns if the "contact_person" field was cleared in this mutation.
func (m *TeamMutation) ContactPersonCleared() bool {
	_, ok := m.clearedFields[team.FieldContactPerson]
	return ok
}

// ResetContactPerson resets all changes to the "contact_person" field.
func (m *TeamMutation) ResetContactPerson() {
	m.contact_person = nil
	delete(m.clearedFields, team.FieldContactPerson)
}

// SetContactPhone sets the "contact_phone" field.
func (m *TeamMutation) SetContactPhone(s string) {
	m.contact_phone = &s
}

// ContactPhone returns the value of the "contact_phone" field in the mutation.
func (m *TeamMutation) ContactPhone() (r string, exists bool) {
	v := m.contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldContactPhone returns the old "contact_phone" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactPhone: %w", err)
	}
	return oldValue.ContactPhone, nil
}

// ClearContactPhone clears the value of the "contact_phone" field.
func (m *TeamMutation) ClearContactPhone() {
	m.contact_phone = nil
	m.clearedFields[team.FieldContactPhone] = struct{}{}
}

// ContactPhoneCleared returns if the "contact_phone" field was cleared in this mutation.
func (m *TeamMutation) ContactPhoneCleared() bool {
	_, ok := m.clearedFields[team.FieldContactPhone]
	return ok
}

// ResetContactPhone resets all changes to the "contact_phone" field.
func (m *TeamMutation) ResetContactPhone() {
	m.contact_phone = nil
	delete(m.clearedFields, team.FieldContactPhone)
}

// SetContactEmail sets the "contact_email" field.
func (m *TeamMutation) SetContactEmail(s string) {
	m.contact_email = &s
}

// ContactEmail returns the value of the "contact_email" field in the mutation.
func (m *TeamMutation) ContactEmail() (r string, exists bool) {
	v := m.contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldContactEmail returns the old "contact_email" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactEmail: %w", err)
	}
	return oldValue.ContactEmail, nil
}

// ClearContactEmail clears the value of the "contact_email" field.
func (m *TeamMutation) ClearContactEmail() {
	m.contact_email = nil
	m.clearedFields[team.FieldContactEmail] = struct{}{}
}

// ContactEmailCleared returns if the "contact_email" field was cleared in this mutation.
func (m *TeamMutation) ContactEmailCleared() bool {
	_, ok := m.clearedFields[team.FieldContactEmail]
	return ok
}

// ResetContactEmail resets all changes to the "contact_email" field.
func (m *TeamMutation) ResetContactEmail() {
	m.contact_email = nil
	delete(m.clearedFields, team.FieldContactEmail)
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TeamMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[team.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TeamMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, team.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[team.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[team.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, team.FieldUpdatedAt)
}

// AddMatchIDs adds the "matches" edge to the Match entity by ids.
func (m *TeamMutation) AddMatchIDs(ids ...int32) {
	if m.matches == nil {
		m.matches = make(map[int32]struct{})
	}
	for i := range ids {
		m.matches[ids[i]] = struct{}{}
	}
}

// ClearMatches clears the "matches" edge to the Match entity.
func (m *TeamMutation) ClearMatches() {
	m.clearedmatches = true
}

// MatchesCleared reports if the "matches" edge to the Match entity was cleared.
func (m *TeamMutation) MatchesCleared() bool {
	return m.clearedmatches
}

// RemoveMatchIDs removes the "matches" edge to the Match entity by IDs.
func (m *TeamMutation) RemoveMatchIDs(ids ...int32) {
	if m.removedmatches == nil {
		m.removedmatches = make(map[int32]struct{})
	}
	for i := range ids {
		delete(m.matches, ids[i])
		m.removedmatches[ids[i]] = struct{}{}
	}
}

// RemovedMatches returns the removed IDs of the "matches" edge to the Match entity.
func (m *TeamMutation) RemovedMatchesIDs() (ids []int32) {
	for id := range m.removedmatches {
		ids = append(ids, id)
	}
	return
}

// MatchesIDs returns the "matches" edge IDs in the mutation.
func (m *TeamMutation) MatchesIDs() (ids []int32) {
	for id := range m.matches {
		ids = append(ids, id)
	}
	return
}

// ResetMatches resets all changes to the "matches" edge.
func (m *TeamMutation) ResetMatches() {
	m.matches = nil
	m.clearedmatches = false
	m.removedmatches = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.company_name != nil {
		fields = append(fields, team.FieldCompanyName)
	}
	if m.contact_person != nil {
		fields = append(fields, team.FieldContactPerson)
	}
	if m.contact_phone != nil {
		fields = append(fields, team.FieldContactPhone)
	}
	if m.contact_email != nil {
		fields = append(fields, team.FieldContactEmail)
	}
	if m.created_at != nil {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, team.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldName:
		return m.Name()
	case team.FieldCompanyName:
		return m.CompanyName()
	case team.FieldContactPerson:
		return m.ContactPerson()
	case team.FieldContactPhone:
		return m.ContactPhone()
	case team.FieldContactEmail:
		return m.ContactEmail()
	case team.FieldCreatedAt:
		return m.CreatedAt()
	case team.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case team.FieldContactPerson:
		return m.OldContactPerson(ctx)
	case team.FieldContactPhone:
		return m.OldContactPhone(ctx)
	case team.FieldContactEmail:
		return m.OldContactEmail(ctx)
	case team.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case team.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case team.FieldContactPerson:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPerson(v)
		return nil
	case team.FieldContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactPhone(v)
		return nil
	case team.FieldContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactEmail(v)
		return nil
	case team.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case team.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(team.FieldCompanyName) {
		fields = append(fields, team.FieldCompanyName)
	}
	if m.FieldCleared(team.FieldContactPerson) {
		fields = append(fields, team.FieldContactPerson)
	}
	if m.FieldCleared(team.FieldContactPhone) {
		fields = append(fields, team.FieldContactPhone)
	}
	if m.FieldCleared(team.FieldContactEmail) {
		fields = append(fields, team.FieldContactEmail)
	}
	if m.FieldCleared(team.FieldCreatedAt) {
		fields = append(fields, team.FieldCreatedAt)
	}
	if m.FieldCleared(team.FieldUpdatedAt) {
		fields = append(fields, team.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	switch name {
	case team.FieldCompanyName:
		m.ClearCompanyName()
		return nil
	case team.FieldContactPerson:
		m.ClearContactPerson()
		return nil
	case team.FieldContactPhone:
		m.ClearContactPhone()
		return nil
	case team.FieldContactEmail:
		m.ClearContactEmail()
		return nil
	case team.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case team.FieldContactPerson:
		m.ResetContactPerson()
		return nil
	case team.FieldContactPhone:
		m.ResetContactPhone()
		return nil
	case team.FieldContactEmail:
		m.ResetContactEmail()
		return nil
	case team.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case team.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.matches != nil {
		edges = append(edges, team.EdgeMatches)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.matches))
		for id := range m.matches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmatches != nil {
		edges = append(edges, team.EdgeMatches)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMatches:
		ids := make([]ent.Value, 0, len(m.removedmatches))
		for id := range m.removedmatches {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmatches {
		edges = append(edges, team.EdgeMatches)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeMatches:
		return m.clearedmatches
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeMatches:
		m.ResetMatches()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TeamFeeMutation represents an operation that mutates the TeamFee nodes in the graph.
type TeamFeeMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	amount        *float64
	addamount     *float64
	payment_date  *time.Time
	description   *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*TeamFee, error)
	predicates    []predicate.TeamFee
}

var _ ent.Mutation = (*TeamFeeMutation)(nil)

// teamfeeOption allows management of the mutation configuration using functional options.
type teamfeeOption func(*TeamFeeMutation)

// newTeamFeeMutation creates new mutation for the TeamFee entity.
func newTeamFeeMutation(c config, op Op, opts ...teamfeeOption) *TeamFeeMutation {
	m := &TeamFeeMutation{
		config:        c,
		op:            op,
		typ:           TypeTeamFee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamFeeID sets the ID field of the mutation.
func withTeamFeeID(id int32) teamfeeOption {
	return func(m *TeamFeeMutation) {
		var (
			err   error
			once  sync.Once
			value *TeamFee
		)
		m.oldValue = func(ctx context.Context) (*TeamFee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TeamFee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeamFee sets the old TeamFee of the mutation.
func withTeamFee(node *TeamFee) teamfeeOption {
	return func(m *TeamFeeMutation) {
		m.oldValue = func(context.Context) (*TeamFee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamFeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamFeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TeamFee entities.
func (m *TeamFeeMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamFeeMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamFeeMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TeamFee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAmount sets the "amount" field.
func (m *TeamFeeMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *TeamFeeMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the TeamFee entity.
// If the TeamFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFeeMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *TeamFeeMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *TeamFeeMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *TeamFeeMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetPaymentDate sets the "payment_date" field.
func (m *TeamFeeMutation) SetPaymentDate(t time.Time) {
	m.payment_date = &t
}

// PaymentDate returns the value of the "payment_date" field in the mutation.
func (m *TeamFeeMutation) PaymentDate() (r time.Time, exists bool) {
	v := m.payment_date
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentDate returns the old "payment_date" field's value of the TeamFee entity.
// If the TeamFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFeeMutation) OldPaymentDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaymentDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaymentDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentDate: %w", err)
	}
	return oldValue.PaymentDate, nil
}

// ResetPaymentDate resets all changes to the "payment_date" field.
func (m *TeamFeeMutation) ResetPaymentDate() {
	m.payment_date = nil
}

// SetDescription sets the "description" field.
func (m *TeamFeeMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TeamFeeMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TeamFee entity.
// If the TeamFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFeeMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *TeamFeeMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[teamfee.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *TeamFeeMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[teamfee.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *TeamFeeMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, teamfee.FieldDescription)
}

// SetCreatedAt sets the "created_at" field.
func (m *TeamFeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TeamFeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TeamFee entity.
// If the TeamFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TeamFeeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[teamfee.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TeamFeeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[teamfee.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TeamFeeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, teamfee.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TeamFeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TeamFeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TeamFee entity.
// If the TeamFee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamFeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TeamFeeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[teamfee.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TeamFeeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[teamfee.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TeamFeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, teamfee.FieldUpdatedAt)
}

// Where appends a list predicates to the TeamFeeMutation builder.
func (m *TeamFeeMutation) Where(ps ...predicate.TeamFee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamFeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamFeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TeamFee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamFeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamFeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TeamFee).
func (m *TeamFeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamFeeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.amount != nil {
		fields = append(fields, teamfee.FieldAmount)
	}
	if m.payment_date != nil {
		fields = append(fields, teamfee.FieldPaymentDate)
	}
	if m.description != nil {
		fields = append(fields, teamfee.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, teamfee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, teamfee.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamFeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teamfee.FieldAmount:
		return m.Amount()
	case teamfee.FieldPaymentDate:
		return m.PaymentDate()
	case teamfee.FieldDescription:
		return m.Description()
	case teamfee.FieldCreatedAt:
		return m.CreatedAt()
	case teamfee.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamFeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teamfee.FieldAmount:
		return m.OldAmount(ctx)
	case teamfee.FieldPaymentDate:
		return m.OldPaymentDate(ctx)
	case teamfee.FieldDescription:
		return m.OldDescription(ctx)
	case teamfee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case teamfee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown TeamFee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamFeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teamfee.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case teamfee.FieldPaymentDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentDate(v)
		return nil
	case teamfee.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case teamfee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case teamfee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown TeamFee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamFeeMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, teamfee.FieldAmount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamFeeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teamfee.FieldAmount:
		return m.AddedAmount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamFeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teamfee.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	}
	return fmt.Errorf("unknown TeamFee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamFeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teamfee.FieldDescription) {
		fields = append(fields, teamfee.FieldDescription)
	}
	if m.FieldCleared(teamfee.FieldCreatedAt) {
		fields = append(fields, teamfee.FieldCreatedAt)
	}
	if m.FieldCleared(teamfee.FieldUpdatedAt) {
		fields = append(fields, teamfee.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamFeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamFeeMutation) ClearField(name string) error {
	switch name {
	case teamfee.FieldDescription:
		m.ClearDescription()
		return nil
	case teamfee.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case teamfee.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamFee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamFeeMutation) ResetField(name string) error {
	switch name {
	case teamfee.FieldAmount:
		m.ResetAmount()
		return nil
	case teamfee.FieldPaymentDate:
		m.ResetPaymentDate()
		return nil
	case teamfee.FieldDescription:
		m.ResetDescription()
		return nil
	case teamfee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case teamfee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown TeamFee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamFeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamFeeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamFeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamFeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamFeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamFeeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamFeeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown TeamFee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamFeeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown TeamFee edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int32
	username      *string
	password      *string
	email         *string
	full_name     *string
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int32) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int32) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int32, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int32, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int32{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFullName sets the "full_name" field.
func (m *UserMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *UserMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *UserMutation) ResetFullName() {
	m.full_name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.full_name != nil {
		fields = append(fields, user.FieldFullName)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldPassword:
		return m.Password()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFullName:
		return m.FullName()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFullName:
		return m.OldFullName(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFullName:
		m.ResetFullName()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
